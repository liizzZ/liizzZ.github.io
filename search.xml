<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2F2018%2F11%2F20%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆堆是一个完全二叉树，完全充满二叉树。通俗来讲就是只有节点放满一层之后，节点才能继续放在下一层，否则节点继续填充在此层。 堆也被称为二叉堆，满足两个条件 是一颗完全二叉树 父节点一定同时大于（小于）子节点。可分为：最大堆和最小堆。 当用数组来存储堆时，数组元素下标的父子节点有一定的规律可循： 设i为当前节点的索引，（当前环境为索引为0的数组元素不存储节点，根节点的索引为1） 父节点的索引下标为：parent = i/2 左右子节点的索引下标：left = 2*i，right = 2*i+1 （当前环境为索引为0的数组元素存储节点，根节点的索引为0时） 父节点的索引下标为：parent = （i-1）/2 左右子节点的索引下标：left = 2*i+1，right = 2*i+2 基本实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Created by lizzZ on 2018/11/20. */public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity)&#123; data = new Array&lt;E&gt;(capacity); &#125; public MaxHeap()&#123; data = new Array&lt;E&gt;(); &#125; /** * 返回堆中有多少个元素 */ public int getSize()&#123; return data.getSize(); &#125; /** * 返回堆是否为空 */ public boolean isEmpty()&#123; return data.isEmpty(); &#125; /** * 返回完全二叉树数组中表示中，一个索引所表示的元素的父亲节点的索引 */ public int parent(int index)&#123; if (index == 0)&#123; throw new IllegalArgumentException("index-0,doesn't have a parent"); &#125; return (index-1)/2; &#125; /** * 返回完全二叉树数组表示中，一个索引所表示的元素的左子节点的索引 */ public int leftChild(int index)&#123; return (index*2+1); &#125; /** * 返回完全二叉树数组表示中，一个索引所表示的元素的右子节点的索引 */ public int rightChild(int index)&#123; return (index*2+2); &#125;&#125; 添加元素和取出元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 向堆中添加元素 */public void add(E e)&#123; data.addLast(e); siftUp(data.getSize()-1);&#125;/** * 将元素上浮 */public void siftUp(int k)&#123; while (k &gt; 0 &amp;&amp; data.get(k).compareTo(data.get(parent(k)))&gt;0)&#123; data.swap(k,parent(k)); k = parent(k); &#125;&#125;/** * 取出堆中最大的元素 */public E extractMax()&#123; if (data.getSize() == 0)&#123; throw new IllegalArgumentException("heap is Empty"); &#125; E ret = data.get(0); data.swap(0,data.getSize()-1); data.removeLast(); siftDown(0); return ret;&#125;/** * 将元素下沉 */public void siftDown(int k)&#123; while (leftChild(k) &lt; data.getSize())&#123; int j = leftChild(k); if (j+1 &lt; data.getSize() &amp;&amp; data.get(j).compareTo(data.get(j+1))&lt;0)&#123; j = rightChild(k); &#125;//j 是左右子节点中的最大值 if (data.get(k).compareTo(data.get(j))&gt;=0)&#123; break; &#125; data.swap(k,j); k = j; &#125;&#125; 测试将1000000个数字存入堆中，然后将堆的最大元素取出，放入一个数组中，然后进行验算数组中的元素是否按照从大到小排列。 1234567891011121314151617181920public static void main(String[] args) &#123; int n = 1000000; MaxHeap&lt;Integer&gt; maxHeap = new MaxHeap&lt;Integer&gt;(); Random random = new Random(); for (int i = 0;i &lt; n;i++)&#123; maxHeap.add(random.nextInt(Integer.MAX_VALUE)); &#125; int[] arr = new int[n]; for (int i =0;i &lt; n; i++)&#123; arr[i] = maxHeap.extractMax(); &#125; for (int i = 0; i &lt; arr.length-1;i++)&#123; if (arr[i+1] &gt; arr[i])&#123; throw new IllegalArgumentException("ERROR"); &#125; &#125; System.out.println("done");&#125; 替换和拟堆化数组1234567891011121314/** * 取出堆中的最大元素，并e代替它 */public E replace(E e)&#123; if (data.getSize() == 0)&#123; throw new IllegalArgumentException("heap is Empty"); &#125; E ret = data.get(0); data.set(0,e); siftDown(0); return ret;&#125; 123456789/** * 将一个普通的数组拟堆化 */public MaxHeap(E[] arr)&#123; data = new Array&lt;E&gt;(arr); for (int i = parent(arr.length-1);i &gt;=0; i--)&#123; siftDown(i); &#125;&#125; 优先队列普通队列：先进先出，后进后出 优先队列：出队顺序和入队顺序无关，和优先级有关 实现 void enqueue(E); E dequeue(); E getFront(); int getSize(); boolean isEmpty();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和时间赛跑]]></title>
    <url>%2F2018%2F11%2F19%2Ftime%2F</url>
    <content type="text"><![CDATA[前言想起了小学的一篇文章，最记得的是里面的一幅配图，一个小孩在夕阳照耀下努力奔跑。 正文和时间赛跑 林清玄 &#160; &#160; &#160; &#160;读小学的时候，我的外祖母去世了。外祖母生前最疼爱我。我无法排除自己的忧伤，每天在学校的操场上一圈一圈地跑着，跑得累倒在地上，扑在草坪上痛哭。 &#160; &#160; &#160; &#160;那哀痛的日子持续了很久，爸爸妈妈也不知道如何安慰我。他们知道与其欺骗我说外祖母睡着了，还不如对我说实话：外祖母永远不会回来了。 &#160; &#160; &#160; &#160;“什么是永远不会回来了呢？”我问。&#160; &#160; &#160; &#160;“所有时间里的事物，都永远不会回来了。你的昨天过去了，它就永远变成昨天，你再也不能回到昨天了。爸爸以前和你一样小，现在再也不能回到你这么小的童年了。有一天你会长大，你也会像外祖母一样老，有一天你度过了你的所有时间，也会像外祖母永远不能回来了。”爸爸说。 &#160; &#160; &#160; &#160;爸爸等于给我一个谜语，这谜语比课本上的“日历挂在墙壁，一天撕去一页，使我心里着急”和“一寸光阴一寸金，寸金难买寸光阴”还让我感到可怕；也比作文本上的“光阴似箭，日月如梭”更让我觉得有一种说不出的滋味。&#160; &#160; &#160; &#160;以后，我每天放学回家，在庭院时看着太阳一寸一寸地沉进了山头，就知道一天真的过完了。虽然明天还会有新的太阳，但永远不会有今天的太阳了。 &#160; &#160; &#160; &#160;我看到鸟儿飞到天空，它们飞得多快呀。明天它们再飞过同样的路线，也永远不是今天了。或许明天再飞过这条路线，不是老鸟，而是小鸟了。 &#160; &#160; &#160; &#160;时间过的飞快，使我的小心眼里不只是着急，还有悲伤。有一天我放学回家，看到太阳快落山了，就下决心说：“我要比太阳更快回家。”我狂奔回去，站在庭院里喘气的时候，看到太阳还露着半边脸，我高兴地跳起来。那一天我跑赢了太阳。以后我常做这样的游戏，有时和太阳赛跑，有时和西北风比赛，有时一个暑假的作业，我十天就做完了。那时我三年级，常把哥哥五年级的作业拿来做。每一次比赛胜过时间，我就快乐得不知道怎么形容。 &#160; &#160; &#160; &#160;后来的二十年里，我因此受益无穷。虽然我知道人永远跑不过时间，但是可以比原来跑快一步，如果加把劲，有时可以快好几步。那几步虽然很小很小，用途却很大很大。 &#160; &#160; &#160; &#160;如果将来我有什么要教给我的孩子，我会告诉他：假若你一直和时间赛跑，你就可以成功。]]></content>
      <tags>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找树]]></title>
    <url>%2F2018%2F11%2F19%2Ftree%2F</url>
    <content type="text"><![CDATA[前言二分搜索树 平衡二叉树：AVL，红黑树 堆；并查集 线段树，Trie（字典树，前缀树） 二分搜素树二分树:最多有两个孩子，最多有一个父亲，左子树的所有节点的值都小于该节点，右子树的所有节点的值都大于该节点的值 12345class Node&#123; E e; Node left;//左孩子 Node right;//右孩子&#125; 添加元素1234567891011121314151617181920212223242526272829303132333435/*** 向二分查找树中添加新的元素e*/public void add(E e)&#123; if (root == null)&#123; root = new Node(e); size++; &#125;else &#123; add(root,e); &#125;&#125;/*** 向为node为根节点的二分查找树插入元素e，递归算法*/private void add(Node node, E e)&#123; //递归终止条件 if (e.equals(node.data))&#123; return; &#125;else if (e.compareTo(node.data) &lt; 0 &amp;&amp; node.left == null)&#123; node.left = new Node(e); size++; return; &#125;else if (e.compareTo(node.data) &gt; 0 &amp;&amp; node.right == null)&#123; node.right = new Node(e); size++; return; &#125; if (e.compareTo(node.data) &lt; 0)&#123; add(node.left, e); &#125;else &#123; add(node, e); &#125;&#125; 改进添加操作在二叉树中，空节点也可以作为一个二叉树，而上面的递归条件过于繁杂，可以想象一下，在每个子节点的左右节点为空的时候，可以把它当做一个空的二叉树。 1234567891011121314151617181920212223242526272829/*** 向二分查找树中添加新的元素e*/public void add(E e)&#123; if (root == null)&#123; root = new Node(e); size++; &#125;else &#123; root = add(root,e); &#125;&#125;/*** 向为node为根节点的二分查找树插入元素e，递归算法*/private Node add(Node node, E e)&#123; //递归终止条件 if (node == null)&#123; size++; return new Node(e); &#125; if (e.compareTo(node.data) &lt; 0)&#123; node.left = add(node.left, e); &#125;else if(e.compareTo(node.data) &gt; 0)&#123; node.right = add(node, e); &#125; return node;&#125; 查询操作遍历前序遍历 1234567891011public void preOrder()&#123; preOrder(root);&#125;private void preOrder(Node node)&#123; if (node == null)&#123; return; &#125; System.out.println(node.data); preOrder(node.left); preOrder(node.right);&#125; 中序遍历 123456789101112public void inOrder()&#123; inOrder(root);&#125;private void inOrder(Node node)&#123; if (node == null)&#123; return; &#125; inOrder(node.left); System.out.println(node.data); inOrder(node.right);&#125; 后序遍历 1234567891011public void postOrder()&#123; postOrder(root);&#125;private void postOrder(Node node)&#123; if (node == null)&#123; return; &#125; postOrder(node.left); postOrder(node.right); System.out.println(node.data);&#125; 层序遍历（广度优先遍历）1234567891011121314151617 /** * 层序遍历 */public void levelOrder()&#123; Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;(); q.add(root); while (!q.isEmpty())&#123; Node cur = q.remove(); System.out.println(cur.data); if (cur.left != null)&#123; q.add(cur.left); &#125;else if (cur.right != null)&#123; q.add(cur.right); &#125; &#125;&#125; 查找最小值和最大值12345678910111213141516171819 /** * 寻找二分搜索树的最小元素 */public E minimum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("bst is empty!"); &#125; return minimum(root).data;&#125; /** * 返回以node为根节点的二分查找树的最小值所在的节点 */private Node minimum(Node node)&#123; if (node.left == null)&#123; return node; &#125; return minimum(node.left);&#125; 12345678910111213141516171819 /** * 寻找二分搜索树的最大元素 */public E maximum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("bst is empty!"); &#125; return maximum(root).data;&#125; /** * 返回以node为根节点的二分查找树的最大值所在的节点 */public Node maximum(Node node)&#123; if (node.right == null)&#123; return node.right; &#125; return maximum(node.right);&#125; 删除任意节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 从二分查找树中删除元素为e的节点 */public void remove(E e)&#123; root = remove(root,e);&#125;/** * 删除以node为根节点的二分查找树的元素e节点 */private Node remove(Node node,E e)&#123; if (node == null)&#123; return null; &#125; if (e.compareTo(node.data)&lt;0)&#123; node.left = remove(node.left,e); return node; &#125; else if (e.compareTo(node.data)&gt;0)&#123; node.right = remove(node.right,e); return node; &#125; else &#123; //待删除结点的左子树为空 if (node.left == null)&#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; //待删除结点的右子树为空 else if (node.right == null)&#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; /** * 待删除的节点都不为空 * 找到比待删除节点大的最小节点，或者找到比待删除节点小的最大节点， * 把它移动到待删除节点的位置，然后取代它。 * 这里选择找到比删除结点大的最小节点 */ else &#123; Node successor = minimum(node.right); successor.right = removeMin(node.right); //size++; successor.left = node.left; node.left = node.right = null; //size--; return successor; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与队列]]></title>
    <url>%2F2018%2F11%2F18%2Fstack_queue%2F</url>
    <content type="text"><![CDATA[前言主要关于数据结构中的栈与队列，队列根据底层的实现，分为数组队列和循环队列。 栈相对于数组，栈对应的操作是数组的子集。 栈只能从一端添加数据，同一端取出数据，这一端称为栈顶。 栈是一种先进后出的数据结构（Last in first out）。 栈的实现 void push(E) E pop() E peek() int getSize() boolean isEmpty() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Created by lizzZ on 2018/11/17. */public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; Array&lt;E&gt; array; public ArrayStack(int capacity)&#123; array = new Array&lt;E&gt;(capacity); &#125; public ArrayStack()&#123; array = new Array&lt;E&gt;(); &#125; public int getCapacity()&#123; return array.getCapacity(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public void push(E e) &#123; array.addLast(e); &#125; @Override public E pop() &#123; return array.removeLast(); &#125; @Override public E peek() &#123; return array.getLast(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append("Stack: "); sb.append("["); for (int i = 0; i &lt;array.getSize(); i++)&#123; sb.append(array.get(i)); if (i != array.getSize()-1)&#123; sb.append(", "); &#125; &#125; sb.append("] top"); return sb.toString(); &#125;&#125; 队列 int getSize() boolean isEmpty() void enqueue() E dequeue() E getFront() 数组队列数组队列的实现，底层基于数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayQueue(int capacity)&#123; array = new Array&lt;E&gt;(capacity); &#125; public ArrayQueue()&#123; array = new Array&lt;E&gt;(); &#125; public int getCapacity()&#123; return array.getCapacity(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; @Override public void enqueue(E e) &#123; array.addLast(e); &#125; @Override public E dequeue() &#123; return array.removeFirst(); &#125; @Override public E getFront() &#123; return array.get(0); &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(String.format("Queue: size = %d , capacity = %d\n",array.getSize() ,array.getCapacity())); sb.append("front ["); for (int i = 0; i &lt; getSize(); i++)&#123; sb.append(array.get(i)); if(i != getSize()-1)&#123; sb.append(","); &#125; &#125; sb.append("] tail"); return sb.toString(); &#125;&#125; 循环队列假设队列为一个环状， 设定 front == tail 时，队列为空，front == (tail+1)%capacity 时，队列为满。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; /** * 补在复用Array动态数组，自定义底层实现 */ private E[] data; private int front, tail; private int size; /** * 给capacity容量增加1，当空闲容量最后只剩下1时，此时设定queue为满 */ public LoopQueue(int capacity)&#123; data = (E[]) new Object[capacity + 1]; front = 0; tail = 0; size = 0; &#125; public LoopQueue()&#123; this(10); &#125; public int getCapacity()&#123; return data.length-1; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return front == tail; &#125; @Override public void enqueue(E e) &#123; if (front == (tail+1)%data.length)&#123; resize(getCapacity() * 2); &#125; data[tail] = e; tail = (tail+1)%data.length; size++; &#125; /** * 扩容底层数组 */ private void resize(int newCapacity) &#123; E[] newData = (E[]) new Object[newCapacity + 1]; for (int i = 0; i &lt; size; i++)&#123; newData[i] = data[(i + front) % data.length]; &#125; data = newData; front = 0; tail = size; &#125; @Override public E dequeue() &#123; if (isEmpty())&#123; throw new IllegalArgumentException("connot enqueue,the queue is empty"); &#125; E ret = data[front]; front = (front+1)%data.length; size--; if (size == getCapacity()/4 &amp;&amp; getCapacity()/2 != 0)&#123; resize(getCapacity()/2); &#125; return ret; &#125; @Override public E getFront() &#123; if (isEmpty())&#123; throw new IllegalArgumentException("connot enqueue,the queue is empty"); &#125; return data[front]; &#125; public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(String.format("Queue: size = %d , capacity = %d\n",getSize() ,getCapacity())); sb.append("front ["); for (int i = front; i != tail; i = (i+1)%data.length)&#123; sb.append(data[i]); if((i+1)%data.length != tail)&#123; sb.append(","); &#125; &#125; sb.append("] tail"); return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java数据结构中的数组]]></title>
    <url>%2F2018%2F11%2F17%2FArray%2F</url>
    <content type="text"><![CDATA[前言对于java中的数组，是一种占有固定内存的数据结构，这里对数组进行二次封装，进行简单的增删改查，实现对数组的动态操作。使用泛型定义数组的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178public class Array&lt;E&gt; &#123; private E[] data; private int size; public boolean isEmpty()&#123; return size == 0; &#125; /** * 获取数组的元素个数 */ public int getSize()&#123; return size; &#125; /** * 获取数组的容量大小 */ public int getCapacity()&#123; return data.length; &#125; /** * 传入数组容量构造Array * size 置为0 */ public Array(int capacity)&#123; // new E[capacity], java中不支持这种写法 data = (E[])new Object[capacity]; size = 0; &#125; /** * 空参构造器，默认数组容量为10 */ public Array()&#123; this(10); size = 0; &#125; /** * 向所有元素最后添加一个新元素 */ public void addLast(E e)&#123;// if(size == data.length)&#123;// throw new IllegalArgumentException("AddLast failed ,Array is full");// &#125;// data[size] = e;// size++; add(size,e); &#125; /** * 向所有元素前添加一个新元素 */ public void addFirst(E e)&#123; add(0,e); &#125; /** * 向指定index位置插入一个新元素 */ public void add(int index,E e)&#123; if (index &lt; 0 || index &gt; size)&#123; throw new IllegalArgumentException("add failed, index &gt; size or index &lt; 0"); &#125; // 如果此时的数组容量已经满了，则为数组扩容，把数组的容量动态扩充为以前的2倍 if(size == data.length)&#123; resize(2 * data.length); &#125; for(int i = size-1;i&gt;=index ;i--)&#123; data[i+1] = data[i]; &#125; data[index] = e; size++; &#125; /** * 获取指定位置index的值 */ public E get(int index)&#123; if(index &gt; size-1 || index &lt; 0)&#123; throw new IllegalArgumentException("get fialed, index is illegal"); &#125; return data[index]; &#125; /** * 修改位置index的值为指定的值 */ public void set(int index, E e)&#123; if(index &gt; size-1 || index &lt; 0)&#123; throw new IllegalArgumentException("get fialed, index is illegal"); &#125; data[index] = e; &#125; /** * 查找数组中是否包含是某元素 */ public boolean contains(E e)&#123; for (int i = 0; i &lt; size; i++)&#123; if (data[i] == e)&#123; return true; &#125; &#125; return false; &#125; /** * 查找某元素在数组的index索引，若不存在，则返回-1 */ public int find(E e)&#123; for (int i = 0; i &lt; size; i++ )&#123; if (data[i] == e)&#123; return i; &#125; &#125; return -1; &#125; /** * 删除索引index的值，并返回 */ public E remove(int index)&#123; if (index &lt; 0 || index &gt;= size)&#123; throw new IllegalArgumentException("remove fialed. index is illegal"); &#125; E ret = data[index]; for (int i = index; i &lt; size-1; i++)&#123; data[index] = data[index+1]; &#125; size--; data[size] = null; if(size == data.length/4 &amp;&amp; data.length/2 != 0)&#123; resize(data.length /2); &#125; return ret; &#125; public E removeLast()&#123; return remove(size-1); &#125; public E removeFirst()&#123; return remove(0); &#125; public void removeByElement(E e)&#123; int i = find(e); remove(i); &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(String.format("Array: size = %d , capacity = %d\n",size ,data.length)); sb.append("["); for (int i = 0; i &lt; size; i++)&#123; sb.append(data[i]); if(i != size-1)&#123; sb.append(","); &#125; &#125; sb.append("]"); return sb.toString(); &#125; private void resize(int newCapacity) &#123; E[] newData = (E[])new Object[newCapacity]; for (int i = 0; i &lt; size; i++)&#123; newData[i] = data[i]; &#125; data = newData; &#125;&#125; 测试数据类 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; Array&lt;Integer&gt; arr = new Array(); for (int i = 0; i &lt; 10; i++)&#123; arr.addLast(i); &#125; System.out.print(arr); arr.add(1,100); System.out.print(arr); arr.addFirst(-1); System.out.print(arr); arr.remove(1); System.out.print(arr); arr.remove(1); System.out.print(arr); arr.remove(1); System.out.print(arr); arr.remove(1); System.out.print(arr); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-Django框架]]></title>
    <url>%2F2018%2F11%2F04%2Fpython-Django%2F</url>
    <content type="text"><![CDATA[Django简介Django，是用python语言写的开源web开发框架，并遵循MVC设计。劳伦斯出版集团为了开发以新闻内容为主的网站，而开发出来的框架，于2005年7月在BSD许可证下发布。这个名称来源于比利时的爵士音乐家DjangoReinhardt，一个吉普赛人，主要以演奏吉他为主，还演奏过小提琴等。由于Django在今年的迅速发展，应用越来越广泛，被著名的IT开发杂志SDTimes评选为2013DTimes100.位列API、库和框架分类第六位，被认为是这个领域的娇娇者。Django的主要目的是简便，快速的开发数据库驱动的网站。强调代码复用，多个组件可以方便的以插件的形式服务整个框架，Django有许多的功能强大的第三方插件，甚至可以很方便的开发出自己的工具包，使得Django具有很强的可扩展性。还强调了快速开发和DRY原则。 Django遵循MVC设计，并有一个专有名词：MVT MVT各部分功能M：Model，与MVC的M功能相同，负责与数据库交互，进行数据处理 V：View，与MVC的C功能相同，接受请求，进行业务处理，返回应答 T：Template，与MVC的V功能相同，负责封装构造要返回的HTML Django安装django1pip install django 创建项目（test1：项目名），test1下有一个同名的test1目录和manage.py文件 1django-admin startproject test1 manage.py：项目的管理文件 内层test1目录__init__.py：说明目录是一个python包 settings：项目的配置文件 urls.py：进行url路由的配置 wsgi.py：web服务器和Django的交互入口 在Django中，每一个模块就是一个应用，一个项目有很多个应用组成，每一个应用完成一个特定的功能，创建应用的命令（booktest：应用名） 1python manage.py startapp booktest booktest目录说明__init__.py：说明目录是一个python模块 models.py：写和数据库相关的内容 views.py：接收请求，进行处理，与M，T进行交互，返回应答，定义处理函数，视图函数 tests.py：写测试代码的文件 admin.py：网站管理相关的文件 apps.py： 创建一个应用后，还需要做一步：建立应用和项目之间的联系，需要对应用进行注册。 进入项目根目录下与项目同名的目录，修改settings.py：INSTALLED_APPS这个列表中加上需要增加的应用 运行web开发服务器:默认端口是：8000 1python manage.py runserver ORMDjango中内嵌了ORM框架，ORM框架可以将类和数据表进行对应起来，只需要通过类和对象就可以对数据表进行操作。 O：Object，对象-类 R： Relations，关系，数据库中的表 M：Mapping，映射 通过类和对象操作对应的数据表，不需要写SQL语句。 模型类生成迁移文件 1python manage.py makemigrations 执行生成表 1python manage.py migrate]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础汇总]]></title>
    <url>%2F2018%2F11%2F02%2Fpython-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数值进制数，二进制以0b开头，八进制以0o开头，十六进制以0x开头其他进制的整数，只要打印，就一定会以十进制的数显示 python中，如果显示的数字过大，对位数不确定，可以使用_来间隔，对数字本身没有影响 对浮点小数进行运算时候，可能会得到一个不精确的结果，这是所有语言都一样的。 字符串可以使用单引号或者双引号来表示。单双引号不能混合使用。单双引号不能跨行使用，不会保留字符串格式三重引号可以跨行使用，并且会保留字符串格式 字符串复制，可以使用“abc”* 2 =====&gt; “abcabc” 对象是一个在内存中用来保存数据的一块区域对象保存着三种数据：id，type，value // 表示整除运算符，这个表示一个整除操作，减去余数后得出一个最大的结果：100//51=1 and or notpython中的逻辑运算符中的与或运算符是短路的与非布尔值的逻辑运算：1 and 2，这个表达式的返回值是2 , 而0 and 2 返回值是 0 命名空间（namespace）：命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间中，每一个作用域都有一个对应的命名空间。实际上就是一个字典 序列列表（list）、元组（tuple）、字典（dict）、集合（set） 列表可以存储任意对象，但是一般不这样做，一般列表中存储相同类型的对象，类似于java中的数组in、not in ：检查指定元素是否在列表中列表的索引可以是负数，表示从尾部开始向前计数del ：关键字，可以删除列表中的元素 元组的括号可以省略，前提是元组不为空元组中的元素为一个元素时，至少需要一个逗号，不能不带逗号元组的解包：把元组中的每一个值遍历赋值给一个变量：a，b，c，d = tuple，当变量数量没有元组中的元素多时，需要使用*x来获取剩余的元素，x将以列表的方式存储 快速交换两个元素的值：a，b = b，a 列表的方法： 12345678copy()append()insrt()extend()clear()pop()remove()reverse() 字典的方法： update()：将其他字典的键值对添加到当前字典，如有重复的键，则覆盖 popitem()：随机删除一个键值对，一般都是最后一个，并返回一个元组，有两个元素，分别是删除的键和值 pop() copy()： keys()：返回一个序列，保存所有的key values()：返回所有的value items()：返回一个序列，包含双值的子序列 集合运算：&amp;：交集运算|：并集运算-：差集运算^：异或运算&lt;=： &gt;=： 函数函数在调用的时候，解析器不会检查实参的类型，实参可以传递任意类型的对象。 函数可以接受不定长的参数个数，使用*a，将不定长的参数存入一个元组中。带星号的形参只能有一个。可变参数不是必须写在所有参数的后面，但是可变参数后面的参数必须使用关键字参数的形式来传递，加“=” **形参：可以接受其他没有形参的关键字参数，他会将这些参数保存到一个字典中。必须是写在参数最后面 传递实参时，可以在序列类型的参数面前加 *arg：接受所有的位置参数**keyargs：接受所有的关键字参数 返回值：可以是任何类型，甚至可以是一个函数 递归：整体思想，将一个大问题分解为一个个小问题，知道问题无法分解时，再去解决小问题基线条件、递归条件 print()：输出函数，此时再次输出会换行，如果不想换行，可以： print(&quot;%s*%s=%s\t&quot;%(i,j,i*j),end=&quot;&quot;)type()：检查值的类型isinstance()：检查对象是否是类的实例int()，float()，str()，bool()：类型转换四个函数input（“请输入内容”）：返回值是一个字符串，也可以用于暂止程序的运行time()：获取当前时间，返回值是秒len()：可以获取列表的长度，字典的键值对个数min()，max()：这两个函数可以获取最大最小值range()：可以用来生成自然数的序列 dict()：创建字典：d = dict（name=‘lz’，age=18） id()：查看对象的idhelp（a）：内置函数，可以查询python中函数的用法，a传递的是函数对象（函数名称） locals()：获取当前作用域的命名空间、返回值是一个字典 匿名函数：lambda 函数表达式（语法糖）：创建函数的又一种方式，专门用来创建一些简单的函数语法：lambda 参数列表 ： 返回值 高阶函数接受一个或多个函数参数返回值为函数二者条件满足其一即为高阶函数 map()：可以对迭代对象中的所有元素进行操作，然后添加到一个新的对象中返回sort()：对列表中的元素进行排序，默认是比较列表的元素大小，可以接受一个关键字参数key，key需要一个函数作为参数，每次都会调用列表的元素去调用函数，然后以函数的返回值进行比较列表元素的大小，按升序排列sorted()：基本和sort()元素一致，但是sorted可以对任意序列进行排序，并且不会对原来的序列有改变，会返回一个新的序列 装饰器：可以对原有的函数进行功能上的扩展，在实际开发中，都是通过装饰器来进行对函数的扩展的。还可以使用类似于java注解的方式引用装饰器@装饰器，可以同时指定多个装饰器，函数会按照由内向外的顺序进行装饰。 方法方法和函数基本上是一样的，但是方法必须在使用：对象.方法：来调用 关键字is，is not：比较的是对象的 id 是否相等，== 和！= 比较的是对象的value值是否相等 global：声明修饰函数内的变量作用域为全局变量，一般情况下函数内部是不允许修改全局变量的，固要此声明 类使用类创建对象，就像调用函数一样。 类也是一个对象，类就是一个用来创建对象的对象类是一个type类型的对象，定义类实际上就是定义了一个type类型的对象 实际上多有事物都是由两部分组成：数据（属性）行为（方法） 类中的所有属性都是实例的共有属性 在类中定义的函数被成为方法类中的方法的第一个参数是调用这个方法的对象本身 类中存在一些特殊方法（魔术方法）：以__开头，以__结尾，这些方法不需要对象对用，自己运行特殊方法需要知道什么时候调用有什么作用 类.__bases__ 属性可以直接获取当前类的所有父类 类中的特殊方法__len__() ,可以在外部使用 len 函数获取它的长度 属性、方法：类属性可以通过类或类的实例获取得到，但是只能通过类对象来修改，不能通过使用类的实例对象修改实例属性只能通过类实例来修改获取，无法通过类对象修改获取@classmethod修饰的的方法，是一个类方法，第一个参数是cls，cls也是会被自动传递，cls就是当前类对象类方法可以通过类去调用，也可以通过实例去调用，没有区别， @staticmethod：静态方法，不需要制定默认参数，不会自动传递默认参数。也可以被类调用或者类实例调用 静态方法基本上是与当前类无关的方法，他只是一个保存当前类的函数，静态方法一般都是一些工具方法， 垃圾回收没有被变量引用的对象就是垃圾，python自带垃圾回收机制 __del__（）：特殊方法，在垃圾被回收前调用__str__（）：在尝试将对象转换成字符串的时候调用__rerp__（）： 对象在交互模式中直接输出的结果 模块引入模块：1、import 【】：2、from 【】 import *： 一个.py 文件就是一个模块as 别名：为模块起一个别名 __name__ 属性：可以获取模块的名字，属性值为 __main__ 的就是主模块 包package ，包也是一个模块，普通模块是一个py文件，包是一个文件夹 包中必须有一个__init__.py 文件，这个文件可以包含包中的主要内容 __pycache__ 是模块的缓存文件包，存储临时的编译文件，二进制编码，以十六进制显示 异常123456try ： 代码块except： 代码块else： 代码块 文件操作文件的步骤： 打开文件 操作文件 关闭文件 在windows下，可以使用 / 代替\ ,或者\\代替\，或者使用原始字符串：r&#39;c:\another\a.txt&#39; with ... as ... 语句 12with open(filename) as file_obj: 代码块 open默认是以文本文件打开的，但是默认编码为None，处理文本文件时，必须指定编码方式 1open(file, mode='r', buffering=-1, encoding_=None, errors=None, newline=None, closefd=True, opener=None) 123file_name = a.txt# 打开file_name对应的文件，返回一个对象，这个对象就代表了当前打开的文件file_obj = open（file_name，encoding = ‘utf-8’） open默认是只读取文件，如要写入，需要指定参数“r”“w”，此时使用wirte（）函数会覆盖原有内容，“b”指定读取二进制文件，以字节为单位 read()：会直接将全部文件内容一次加载到内存 write()：返回写入字符的个数 读取模式 t 读取文本文件（默认值） b 读取二进制文件 123456789101112131415161718with open(file_name , 'rb') as file_obj: # 读取文本文件时，size是以字符为单位的 # 读取二进制文件时，size是以字节为单位 # print(file_obj.read(100)) # 将读取到的内容写出来 # 定义一个新的文件 new_name = 'aa.flac' with open(new_name , 'wb') as new_obj: # 定义每次读取的大小 chunk = 1024 * 100 while True : # 从已有的对象中读取数据 content = file_obj.read(chunk) # 内容读取完毕，终止循环 if not content : break # 将读取到的数据写入到新对象中 new_obj.write(content) 读取大文件文件 read(num)：指定每次读取的单位 可以使用readline()，返回一行的内容 可以使用readlines()，返回一个列表，元素是每一行的内容 直接使用for循环遍历 fileobj ，读取的元素是每一行的内容 使用open()打开文件时必须要指定打开文件所要做的操作（读、写、追加） 如果不指定操作类型，则默认是 读取文件 ， 而读取文件时是不能向文件中写入的 r 表示只读的，如果文件不存在会报错 w 表示是可写的，使用w来写入文件时，如果文件不存在会创建文件，如果文件存在则会截断文件，截断文件指删除原来文件中的所有内容 a 表示追加内容，如果文件不存在会创建文件，如果文件存在则会向文件中追加内容 x 用来新建文件，如果文件不存在则创建，存在则报错 + 为操作符增加功能 r+，w+，a+ 12with open(file_name , 'w' , encoding='utf-8') as file_obj:with open(file_name , 'r+' , encoding='utf-8') as file_obj: tell()：告诉当前读取到文件的位置seek()：修改当前读取到的文件，两个参数，一是切换到的位置，二是计算位置方式：0 从头开始 1从当前位置开始计算 2 从最后位置开始计算 其他操作 os.listdir() 获取指定目录的目录结构：需要一个路径作为参数，会获取到该路径下的目录结构，默认路径为./ 当前目录，该方法会返回一个列表，目录中的每一个文件（夹）的名字都是列表中的一个元素 os.getcwd()：返回当前所在的目录 os.chdir()：切换当前所在的目录 os.mkdir()：创建目录 os.rmdir()：删除目录 os.remove()：删除文件 os.rename(&#39;旧名字&#39;,&#39;新名字&#39;)可以对一个文件或目录进行重命名，也可以用来移动一个文件]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python-pip安装scrapy报错]]></title>
    <url>%2F2018%2F10%2F23%2Fpython-pip%E5%AE%89%E8%A3%85scrapy%E6%A1%86%E6%9E%B6%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[问题1pip install scrapy 安装失败报错如下： 1234error: Microsoft Visual C++ 14.0 is required. Get it with "Microsoft Visual C++ Build Tools": http://landinghub.visualstudio.com/visual-cpp-build-tools ----------------------------------------Command "c:\opt\python\python37\python.exe -u -c "import setuptools, tokenize;__file__='C:\\Users\\LIANGZ~1\\AppData\\Local\\Temp\\pip-install-zie5yzkg\\Twisted\\setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" install --record C:\Users\LIANGZ~1\AppData\Local\Temp\pip-record-qjxc0wyd\install-record.txt --single-version-externally-managed --compile" failed with error code 1 in C:\Users\LIANGZ~1\AppData\Local\Temp\pip-install-zie5yzkg\Twisted\ 解决进入：https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted ctrl+F，搜索Twisted,下载对应的版本，我下载的是最下面的那个[Twisted-18.9.0-cp37-cp37m-win_amd64.whl],安装 1pip install d:\Twisted-18.9.0-cp37-cp37m-win_amd64.whl 再安装scrapy 1pip install scrapy 此时已可以安装成功]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-网络爬虫-7]]></title>
    <url>%2F2018%2F10%2F22%2Fpython-21%E5%A4%A9%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-7%2F</url>
    <content type="text"><![CDATA[AjaxAJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax）如果需要更新内容，必须重载整个网页页面。因为传统的在传输数据格式方面，使用的是XML语法。因此叫做AJAX，其实现在数据交互基本上都是使用JSON。使用AJAX加载的数据，即使使用了JS，将数据渲染到了浏览器中，在右键-&gt;查看网页源代码还是不能看到通过ajax加载的数据，只能看到使用这个url加载的html代码。 获取ajax数据的方式 直接分析ajax调用的接口。然后通过代码请求这个接口。 使用Selenium+chromedriver模拟浏览器行为获取数据。 方式 优点 缺点 分析接口 直接可以请求到数据。不需要做一些解析工作。代码量少，性能高。 分析接口比较复杂，特别是一些通过js混淆的接口，要有一定的js功底。容易被发现是爬虫。 selenium 直接模拟浏览器的行为。浏览器能请求到的，使用selenium也能请求到。爬虫更稳定。 代码量多。性能低。 Selenium+chromedriver获取动态数据Selenium相当于是一个机器人。可以模拟人类在浏览器上的一些行为，自动处理浏览器上的一些行为，比如点击，填充数据，删除cookie等。chromedriver是一个驱动Chrome浏览器的驱动程序，使用他才可以驱动浏览器。当然针对不同的浏览器有不同的driver。以下列出了不同浏览器及其对应的driver： Chrome：https://sites.google.com/a/chromium.org/chromedriver/downloads Firefox：https://github.com/mozilla/geckodriver/releases Edge：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ Safari：https://webkit.org/blog/6900/webdriver-support-in-safari-10/ 安装Selenium和chromedriver： 安装Selenium有很多语言的版本，有java、ruby、python等。我们下载python版本的就可以了。 1pip install selenium 安装chromedriver：下载完成后，放到不需要权限的纯英文目录下就可以了。 快速入门现在以一个简单的获取百度首页的例子来讲下Selenium和chromedriver如何快速入门： 1234567891011from selenium import webdriver# chromedriver的绝对路径driver_path = r'D:\ProgramApp\chromedriver\chromedriver.exe'# 初始化一个driver，并且指定chromedriver的路径driver = webdriver.Chrome(executable_path=driver_path)# 请求网页driver.get("https://www.baidu.com/")# 通过page_source获取网页源代码print(driver.page_source) selenium常用操作更多教程请参考：http://selenium-python.readthedocs.io/installation.html#introduction 关闭页面 driver.close()：关闭当前页面。 driver.quit()：退出整个浏览器。 定位元素 根据id来查找某个元素：find_element_by_id等价于：find_element_by_class_name 12submitTag = driver.find_element_by_id('su')submitTag1 = driver.find_element(By.ID,'su') 根据类名查找元素。 等价于：find_element_by_name 12submitTag = driver.find_element_by_class_name('su')submitTag1 = driver.find_element(By.CLASS_NAME,'su') 根据name属性的值来查找元素。等价于：find_element_by_tag_name 12submitTag = driver.find_element_by_name('email')submitTag1 = driver.find_element(By.NAME,'email') 根据标签名来查找元素。等价于：find_element_by_xpath 12submitTag = driver.find_element_by_tag_name('div')submitTag1 = driver.find_element(By.TAG_NAME,'div') 根据xpath语法来获取元素 12submitTag = driver.find_element_by_xpath('//div')submitTag1 = driver.find_element(By.XPATH,'//div') find_element_by_css_selector：根据css选择器选择元素。等价于： 12submitTag = driver.find_element_by_css_selector('//div')submitTag1 = driver.find_element(By.CSS_SELECTOR,'//div') 要注意，find_element是获取第一个满足条件的元素。find_elements是获取所有满足条件的元素。]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python-网络爬虫-6]]></title>
    <url>%2F2018%2F10%2F16%2Fpython-21%E5%A4%A9%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-6%2F</url>
    <content type="text"><![CDATA[单线程下载表情包12345678910111213141516171819202122232425262728293031323334# 表情包import requestsfrom lxml import etreeimport osimport refrom urllib import requestdef parse_page(url): headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0' &#125; response = requests.get(url,headers=headers) text = response.text html = etree.HTML(text) imgs = html.xpath("//div[@class='page-content text-center']//img[@class!='gif']") for img in imgs: img_url = img.get('data-original') suffix = os.path.splitext(img_url)[1] alt_text = img.get('alt') alt_text = re.sub(r'[\?？\.。！!]','',alt_text) filename = alt_text + suffix request.urlretrieve(img_url,'images/'+ filename) print(filename)def main(): for x in range(1,101): url = 'http://www.doutula.com/photo/list/?page=%d' % x print(url) parse_page(url) breakif __name__ == '__main__': main()]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python-网络爬虫-5]]></title>
    <url>%2F2018%2F10%2F11%2Fpython-21%E5%A4%A9%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-5%2F</url>
    <content type="text"><![CDATA[多线程爬虫有些时候，比如下载图片，因为下载图片是一个耗时的操作。如果采用之前那种同步的方式下载。那效率肯会特别慢。这时候我们就可以考虑使用多线程的方式来下载图片。 多线程介绍多线程是为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也可以有多节车厢。多线程的出现就是为了提高效率。同时它的出现也带来了一些问题。更多介绍请参考：https://baike.baidu.com/item/多线程/1190404?fr=aladdin threading模块threading模块是python中专门提供用来做多线程编程的模块。threading模块中最常用的类是Thread。以下看一个简单的多线程程序： 123456789101112131415161718192021222324252627import threadingimport timedef coding(): for x in range(3): print('%s正在写代码' % x) time.sleep(1)def drawing(): for x in range(3): print('%s正在画图' % x) time.sleep(1)def single_thread(): coding() drawing()def multi_thread(): t1 = threading.Thread(target=coding) t2 = threading.Thread(target=drawing) t1.start() t2.start()if __name__ == '__main__': multi_thread() 查看线程数： 使用threading.enumerate()函数可以查看当前线程的数量 查看当前线程的名字 使用thraeding.current_thread()可以查看当前线程的信息 继承自threading.Thread类：为了让线程代码更好的封装。可以使用threading模块下的Thread类，继承自这个类，然后实现run方法，线程就会自动运行run方法中的代码。示例代码如下： 123456789101112131415161718192021222324import threadingimport timeclass CodingThread(threading.Thread): def run(self): for x in range(3): print('%s正在写代码' % threading.current_thread()) time.sleep(1)class DrawingThread(threading.Thread): def run(self): for x in range(3): print('%s正在画图' % threading.current_thread()) time.sleep(1)def multi_thread(): t1 = CodingThread() t2 = DrawingThread() t1.start() t2.start()if __name__ == '__main__': multi_thread() 同步锁为了解决以上使用共享全局变量的问题。threading提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时就不能进来，直到当前线程处理完后，把锁释放了，其他线程才能进来处理。示例代码如下： 123456789101112131415161718192021import threadingVALUE = 0gLock = threading.Lock()def add_value(): global VALUE gLock.acquire() for x in range(1000000): VALUE += 1 gLock.release() print('value：%d'%VALUE)def main(): for x in range(2): t = threading.Thread(target=add_value) t.start()if __name__ == '__main__': main() Lock版本生产者和消费者模式：生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。但是因为要使用中间变量，中间变量经常是一些全局变量，因此需要使用锁来保证数据完整性。以下是使用threading.Lock锁实现的“生产者与消费者模式”的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import threadingimport randomimport timegMoney = 1000gLock = threading.Lock()# 记录生产者生产的次数，达到10次就不再生产gTimes = 0class Producer(threading.Thread): def run(self): global gMoney global gLock global gTimes while True: money = random.randint(100, 1000) gLock.acquire() # 如果已经达到10次了，就不再生产了 if gTimes &gt;= 10: gLock.release() break gMoney += money print('%s当前存入%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney)) gTimes += 1 time.sleep(0.5) gLock.release()class Consumer(threading.Thread): def run(self): global gMoney global gLock global gTimes while True: money = random.randint(100, 500) gLock.acquire() if gMoney &gt; money: gMoney -= money print('%s当前取出%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney)) time.sleep(0.5) else: # 如果钱不够了，有可能是已经超过了次数，这时候就判断一下 if gTimes &gt;= 10: gLock.release() break print("%s当前想取%s元钱，剩余%s元钱，不足！" % (threading.current_thread(),money,gMoney)) gLock.release()def main(): for x in range(5): Consumer(name='消费者线程%d'%x).start() for x in range(5): Producer(name='生产者线程%d'%x).start()if __name__ == '__main__': main() Condition版的生产者与消费者模式：Lock版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过while True死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。首先对threading.Condition相关的函数做个介绍，threading.Condition类似threading.Lock，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下将一些常用的函数做个简单的介绍： acquire：上锁。 release：解锁。 wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。 notify：通知某个正在等待的线程，默认是第1个等待的线程。 notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。 Condition版的生产者与消费者模式代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import threadingimport randomimport timegMoney = 1000gCondition = threading.Condition()gTimes = 0gTotalTimes = 5class Producer(threading.Thread): def run(self): global gMoney global gCondition global gTimes while True: money = random.randint(100, 1000) gCondition.acquire() if gTimes &gt;= gTotalTimes: gCondition.release() print('当前生产者总共生产了%s次'%gTimes) break gMoney += money print('%s当前存入%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney)) gTimes += 1 time.sleep(0.5) gCondition.notify_all() gCondition.release()class Consumer(threading.Thread): def run(self): global gMoney global gCondition while True: money = random.randint(100, 500) gCondition.acquire() # 这里要给个while循环判断，因为等轮到这个线程的时候 # 条件有可能又不满足了 while gMoney &lt; money: if gTimes &gt;= gTotalTimes: gCondition.release() return print('%s准备取%s元钱，剩余%s元钱，不足！'%(threading.current_thread(),money,gMoney)) gCondition.wait() gMoney -= money print('%s当前取出%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney)) time.sleep(0.5) gCondition.release()def main(): for x in range(5): Consumer(name='消费者线程%d'%x).start() for x in range(2): Producer(name='生产者线程%d'%x).start()if __name__ == '__main__': main() Queue线程安全队列：在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做queue模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下： 初始化Queue(maxsize)：创建一个先进先出的队列。 qsize()：返回队列的大小。 empty()：判断队列是否为空。 full()：判断队列是否满了。 get()：从队列中取最后一个数据。 put()：将一个数据放到队列中。 GIL全局解析器锁python自带的解释器是cpython，cpython解析器实际上是一个假的多线程（在多核CPU中，只能利用一核）。同一时刻只有一个线程在执行，为了保证同一时刻只有一个线程在执行，在cpython中解析器中有一个东西叫做GIL(Global intepreter Lock)，叫做全局解析器锁。这个解析器锁是有必要的。因为cpython解释器的内存管理不是线程安全的，当然除了cpython解释器。还有其他的python解释器，有些解释器是没有GIL锁的，如： Jython：java实现的解释器，不存在GIL锁 IronPython：.net实现的解释器，存在GIL锁 PyPy：python实现的解释器，存在GIL锁 GIL虽然是一个假的多线程，但是在处理一些IO操作的时候，还是可以很大程度上的提高效率的。]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python-网络爬虫-4]]></title>
    <url>%2F2018%2F10%2F10%2Fpython-21%E5%A4%A9%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-4%2F</url>
    <content type="text"><![CDATA[json文件处理：JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。更多解释请见：https://baike.baidu.com/item/JSON/2462549?fr=aladdin json支持的数据格式： 对象（字典）。使用花括号。 数组（列表）。使用方括号。 整形、浮点型、布尔类型还有null类型。 字符串类型（字符串必须要用双引号，不能用单引号）。 多个数据之间使用逗号分开。注意：json本质上就是一个字符串。 字典和列表转JSON：12345678910111213import jsonbooks = [ &#123; 'title': '钢铁是怎样练成的', 'price': 9.8 &#125;, &#123; 'title': '红楼梦', 'price': 9.9 &#125;]json_str = json.dumps(books,ensure_ascii=False)print(json_str) 因为json在dump的时候，只能存放ascii的字符，因此会将中文进行转义，这时候我们可以使用ensure_ascii=False关闭这个特性。在Python中。只有基本数据类型才能转换成JSON格式的字符串。也即：int、float、str、list、dict、tuple。 将json数据直接dump到文件中：json模块中除了dumps函数，还有一个dump函数，这个函数可以传入一个文件指针，直接将字符串dump到文件中。示例代码如下： 123456789101112books = [ &#123; 'title': '钢铁是怎样练成的', 'price': 9.8 &#125;, &#123; 'title': '红楼梦', 'price': 9.9 &#125;]with open('a.json','w') as fp: json.dump(books,fp) 将一个json字符串load成Python对象：1234json_str = '[&#123;"title": "钢铁是怎样练成的", "price": 9.8&#125;, &#123;"title": "红楼梦", "price": 9.9&#125;]'books = json.loads(json_str,encoding='utf-8')print(type(books))print(books) 直接从文件中读取json：1234import jsonwith open('a.json','r',encoding='utf-8') as fp: json_str = json.load(fp) print(json_str) csv文件处理读取csv文件：123456import csvwith open('stock.csv','r') as fp: reader = csv.reader(fp) titles = next(reader) for x in reader: print(x) 这样操作，以后获取数据的时候，就要通过下表来获取数据。如果想要在获取数据的时候通过标题来获取。那么可以使用DictReader。示例代码如下： 123456import csvwith open('stock.csv','r') as fp: reader = csv.DictReader(fp) for x in reader: print(x['turnoverVol']) 写入数据到csv文件：写入数据到csv文件，需要创建一个writer对象，主要用到两个方法。一个是writerow，这个是写入一行。一个是writerows，这个是写入多行。示例代码如下： 123456789101112import csvheaders = ['name','age','classroom']values = [ ('zhiliao',18,'111'), ('wena',20,'222'), ('bbc',21,'111')]with open('test.csv','w',encoding='utf-8',newline='') as fp: writer = csv.writer(fp) writer.writerow(headers) writer.writerows(values) 也可以使用字典的方式把数据写入进去。这时候就需要使用DictWriter了。示例代码如下： 12345678910111213import csvheaders = ['name','age','classroom']values = [ &#123;"name":'wenn',"age":20,"classroom":'222'&#125;, &#123;"name":'abc',"age":30,"classroom":'333'&#125;]with open('test.csv','w',newline='') as fp: writer = csv.DictWriter(fp,headers) # 写入表头数据的时候需要调用 writeheader() writer = csv.writeheader() writer.writerow(&#123;'name':'zhiliao',"age":18,"classroom":'111'&#125;) writer.writerows(values) python操作mysqlPython要想操作MySQL。必须要有一个中间件，或者叫做驱动程序。驱动程序有很多。比如有mysqldb、mysqlclient、pymysql等。在这里，我们选择用pymysql。安装方式也是非常简单，通过命令pip install pymysql即可安装。 数据库连接：12345678910111213import pymysqldb = pymysql.connect( host="127.0.0.1", user='root', password='root', database='pymysql_test', port=3306)cursor = db.cursor()cursor.execute("select 1")data = cursor.fetchone()print(data)db.close() 插入数据：12345678910111213141516171819import pymysqldb = pymysql.connect( host="127.0.0.1", user='root', password='root', database='pymysql_test', port=3306)cursor = db.cursor()sql = """insert into user( id,username,gender,age,password ) values(null,'abc',1,18,'111111');"""cursor.execute(sql)db.commit()db.close() 如果在数据还不能保证的情况下，可以使用以下方式来插入数据： 12345678sql = """insert into user( id,username,gender,age,password ) values(null,%s,%s,%s,%s);"""cursor.execute(sql,('spider',1,20,'222222')) 参数以元组的形式进行传入 查找数据：使用pymysql查询数据。可以使用fetch*方法。 fetchone()：这个方法每次之获取一条数据。 fetchall()：这个方法接收全部的返回结果。 fetchmany(size)：可以获取指定条数的数据。示例代码如下： 12345678910111213cursor = db.cursor()sql = """select * from user"""cursor.execute(sql)while True: result = cursor.fetchone() if not result: break print(result)db.close() 或者是直接使用fetchall，一次性可以把所有满足条件的数据都取出来： 1234567891011cursor = db.cursor()sql = """select * from user"""cursor.execute(sql)results = cursor.fetchall()for result in results: print(result)db.close() 或者是使用fetchmany，指定获取多少条数据： 1234567891011cursor = db.cursor()sql = """select * from user"""cursor.execute(sql)results = cursor.fetchmany(1)for result in results: print(result)db.close() 删除数据：123456789cursor = db.cursor()sql = """delete from user where id=1"""cursor.execute(sql)db.commit()db.close() 更新数据：12345678910conn = pymysql.connect(host='localhost',user='root',password='root',database='pymysql_demo',port=3306)cursor = conn.cursor()sql = """update user set username='aaa' where id=1"""cursor.execute(sql)conn.commit()conn.close() MongoDB数据库操作运行MongoDB 创建数据目录 启动MongoDB之前，首先要给他指定一个数据存储的路径，比如我在MongoDB的安装路径下创建一个data文件夹，专门用来存储数据的，d:opt/mongodb/data 把mongodb的bin目录加入到环境变量中，方便以后调用 执行命令：mongod --dpath D:opt/mongodb/data启动 连接MongoDB在环境变量配置好的前提下，运行：mongo启动客户端 可以使用compass软件作为客户端连接mongodb 将MongoDB制作成windows服务启动 创建配置文件：在mongodb安装路径下创建配置文件mongod.cfg（路径和名字不是必须是这个），在配置文件中添加代码 12logpath=C:\opt\mongodb\Server4.0\log\mongod.logdbpath=C:\opt\mongodb\Server4.0\data logpath是日志文件路径，dbpath是mongodb数据库的储存路径 安装mongodb服务： 使用以下命令 1mongodb --config “cfg配置文件路径” --install 启动mongodb服务：net start mongodb 关闭mongodb服务：net stop mongodb 移除mongodb服务：C:\opt\mongodb\Server4.0\bin\mongod.exe --remove MongoDB常用概念 sql mongobd 解释说明 database database 数据库 table collection 表/集合 row document 行/文档 column field 字段/域 index index 索引 joins joins 表连接，mongodb不支持 primary key primary key 主键，mongodb自动将_id字段设为主键 三元素 数据库，集合，文档 文档：就是关系型数据库的一行，文档是一个对象，由键值对构成，是json的扩展形式 1&#123;&quot;name&quot;:&quot;liizzz&quot;,&quot;location&quot;,&quot;guangzhou&quot;&#125; 集合：关系型数据库中的表，可以存储多个文档，结构可以不固定，可以存储下面的文档在一个集合中 123&#123;"name":"liizzz","location":"guangzhou"&#125;&#123;"name":"lll","birth":"2009-9-8"&#125;&#123;"title":"happyDay","content":"like-xom"&#125; 常用命令db：查看当前数据 show dbs：查看所有数据库 use：切换数据库 db.dropDatabase()：删除当前的数据库 db.集合.insert(value)：添加数据到指定的数据库 db.集合.find()：从指定的数据库中查找数据 python操作mongodb1234567891011121314151617181920212223242526272829303132import pymongo# 获取连接mongodb的对象client = pymongo.MongoClient("127.0.0.1",port=27017)# 获取数据库（如果没有这个数据库也没有关系的）db = client.zhihu# 获取数据中的集合(也就是mysql中的表)collection = db.qa# 写入数据collection.insert_one(&#123;"name":"liizzz"&#125;)# 写入多条数据collection.insert_many([ &#123; "name":"lz", "age":18 &#125;, &#123; "name":"li", "age":19 &#125;])# 查找数据cursor = collection.find()for x in cursor: print(x)result = collection.find_one(&#123;"age":18&#125;)print(result) 数据类型 类型 说明 ObjectID 文档ID String 字符串 Boolean 布尔类型 Integer 整形 Double 浮点型 Array 数组，列表，多个值存储到一个键 Object 用于切入式文档，一个值为一个文档 Null 空 Timestamp 时间戳，表示从1970-1-1到现在的总秒数 Date 存储当前时间，日期的UNIX时间格式]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python-网络爬虫-3]]></title>
    <url>%2F2018%2F10%2F04%2Fpython-21%E5%A4%A9%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-3%2F</url>
    <content type="text"><![CDATA[BeautifulSoup4库和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。lxml 只会局部遍历，而Beautiful Soup 是基于HTML DOM（Document Object Model）的，会载入整个文档，解析整个DOM树，因此时间和内存开销都会大很多，所以性能要低于lxml。BeautifulSoup 用来解析 HTML 比较简单，API非常人性化，支持CSS选择器、Python标准库中的HTML解析器，也支持 lxml 的 XML解析器。Beautiful Soup 3 目前已经停止开发，推荐现在的项目使用Beautiful Soup 4。 安装和文档： 安装：pip install bs4。 查看当前安装的所有模块：pip list 中文文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html 几大解析工具对比： 解析工具 解析速度 使用难度 BeautifulSoup 最慢 最简单 lxml 快 简单 正则 最快 最难 简单使用：123456789101112131415from bs4 import BeautifulSouphtml = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="r"&gt;hello&lt;/h1&gt;&lt;/body&gt;"""# 创建 Beautiful Soup 对象# 使用lxml来进行解析soup = BeautifulSoup(html,"lxml")h1 = soup.find_all("h1",id="r")[0]print(soup.prettify())print(h1) 四个常用的对象：Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag NavigatableString BeautifulSoup Comment 1. Tag：Tag 通俗点讲就是 HTML 中的一个个标签。示例代码如下： 1234567891011121314151617181920212223242526272829303132from bs4 import BeautifulSouphtml = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""#创建 Beautiful Soup 对象soup = BeautifulSoup(html,'lxml')print soup.title# &lt;title&gt;The Dormouse's story&lt;/title&gt;print soup.head# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;print soup.a# &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;print soup.p# &lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;print type(soup.p)# &lt;class 'bs4.element.Tag'&gt; 我们可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是bs4.element.Tag。但是注意，它查找的是在所有内容中的第一个符合要求的标签。如果要查询所有的标签，后面会进行介绍。对于Tag，它有两个重要的属性，分别是name和attrs。示例代码如下： 12345678910111213141516print soup.name# [document] #soup 对象本身比较特殊，它的 name 即为 [document]print soup.head.name# head #对于其他内部标签，输出的值便为标签本身的名称print soup.p.attrs# &#123;'class': ['title'], 'name': 'dromouse'&#125;# 在这里，我们把 p 标签的所有属性打印输出了出来，得到的类型是一个字典。print soup.p['class'] # soup.p.get('class')# ['title'] #还可以利用get方法，传入属性的名称，二者是等价的soup.p['class'] = "newClass"print soup.p # 可以对这些属性和内容等等进行修改# &lt;p class="newClass" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; 2. NavigableString：如果拿到标签后，还想获取标签中的内容。那么可以通过tag.string获取标签中的文字。示例代码如下： 12345print soup.p.string# The Dormouse's storyprint type(soup.p.string)# &lt;class 'bs4.element.NavigableString'&gt;thon 3. BeautifulSoup：BeautifulSoup 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 Tag 对象,它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法.因为 BeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name 12soup.name# '[document]' 4. Comment：Tag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分: 12345markup = "&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;"soup = BeautifulSoup(markup)comment = soup.b.stringtype(comment)# &lt;class 'bs4.element.Comment'&gt; Comment 对象是一个特殊类型的 NavigableString 对象: 12comment# 'Hey, buddy. Want to buy a used parser' 遍历文档树： contents和children： 123456789101112131415161718192021222324html_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc,'lxml')head_tag = soup.head# 返回所有子节点的列表print(head_tag.contents)# 返回所有子节点的迭代器for child in head_tag.children: print(child) strings 和 stripped_strings 123456789101112131415161718如果tag中包含多个字符串 [2] ,可以使用 .strings 来循环获取：for string in soup.strings: print(repr(string)) # u"The Dormouse's story" # u'\n\n' # u"The Dormouse's story" # u'\n\n' # u'Once upon a time there were three little sisters; and their names were\n' # u'Elsie' # u',\n' # u'Lacie' # u' and\n' # u'Tillie' # u';\nand they lived at the bottom of a well.' # u'\n\n' # u'...' # u'\n' 输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容： 123456789101112for string in soup.stripped_strings: print(repr(string)) # u"The Dormouse's story" # u"The Dormouse's story" # u'Once upon a time there were three little sisters; and their names were' # u'Elsie' # u',' # u'Lacie' # u'and' # u'Tillie' # u';\nand they lived at the bottom of a well.' # u'...' 搜索文档树 find和find_all方法 搜索文档树，一般用得比较多的就是两个方法，一个是find，一个是find_all。find方法是找到第一个满足条件的标签后就立即返回，只返回一个元素。find_all方法是把所有满足条件的标签都选到，然后返回回去。使用这两个方法，最常用的用法是出入name以及attr参数找出符合要求的标签。 1soup.find_all("a",attrs=&#123;"id":"link2"&#125;) 或者是直接传入属性的的名字作为关键字参数： 1soup.find_all("a",id="link2") select方法 使用以上方法可以方便的找出元素。但有时候使用css选择器的方式可以更加的方便。使用css选择器的语法，应该使用select方法。以下列出几种常用的css选择器方法：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-网络爬虫-2]]></title>
    <url>%2F2018%2F09%2F29%2Fpython-21%E5%A4%A9%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-2%2F</url>
    <content type="text"><![CDATA[Xpath语法什么是XPath？xpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历 XPath开发工具 Chrome插件XPath Helper。 Firefox插件Try XPath。 XPath语法XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。 使用//获取整个页面当中的元素，然后写上标签名，然后再提取谓词进行提取，比如 1//div[@class='abc'] 注意： /和// 的区别，/代表只获取直接子节点，//获取子孙节点，一般//用的比较多，当然也要示情况而定的 contains：有时候某个属性中包含了多个值，可以使用contains函数 谓词的下标是从1开始的 选取节点 表达式 描述 示例 结果 nodename 选取此节点的所有子节点 bookstore 选取bookstore下所有的子节点 / 如果是在最前面，代表从根节点选取。否则选择某节点下的某个节点 /bookstore 选取根元素下所有的bookstore节点 // 从全局节点中选择节点，随便在哪个位置 //book 从全局节点中找到所有的book节点 @ 选取某个节点的属性 //book[@price] 选择所有拥有price属性的book节点 . 当前节点 ./a 选取当前节点下的a标签 谓语： 谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果： 路径表达式 描述 /bookstore/book[1] 选取bookstore下的第一个子元素 /bookstore/book[last()] 选取bookstore下的倒数第二个book元素。 bookstore/book[position()&lt;3] 选取bookstore下前面两个子元素。 //book[@price] 选取拥有price属性的book元素 //book[@price=10] 选取所有属性price等于10的book元素 通配符 *表示通配符。 通配符 描述 示例 结果 * 匹配任意节点 /bookstore/* 选取bookstore下的所有子元素。 @* 匹配节点中的任何属性 //book[@*] 选取所有带有属性的book元素。 选取多个路径： 通过在路径表达式中使用“|”运算符，可以选取若干个路径。示例如下： 12//bookstore/book | //book/title# 选取所有book元素以及book元素下所有的title元素 运算符： 略！ Lxml模块lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。 lxml和正则一样，也是用 C 实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。 lxml python 官方文档：http://lxml.de/index.html 需要安装C语言库，可使用 pip 安装：pip install lxml 基本使用：我们可以利用他来解析HTML代码，并且在解析HTML代码的时候，如果HTML代码不规范，他会自动的进行补全。示例代码如下： 12345678910111213141516171819202122# 使用 lxml 的 etree 库from lxml import etree text = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; # 注意，此处缺少一个 &lt;/li&gt; 闭合标签 &lt;/ul&gt; &lt;/div&gt;'''#利用etree.HTML，将字符串解析为HTML文档html = etree.HTML(text) # 按字符串序列化HTML文档result = etree.tostring(html) print(result) 输入结果如下： 1234567891011&lt;html&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到。lxml会自动修改HTML代码。例子中不仅补全了li标签，还添加了body，html标签。 从文件中读取html代码：除了直接使用字符串进行解析，lxml还支持从文件中读取内容。我们新建一个hello.html文件： 12345678910&lt;!-- hello.html --&gt;&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 然后利用etree.parse()方法来读取文件。示例代码如下： 1234567from lxml import etree# 读取外部文件 hello.htmlhtml = etree.parse('hello.html')result = etree.tostring(html, pretty_print=True)print(result) 输入结果和之前是相同的。 在lxml中使用XPath语法： 获取所有li标签： 12345678from lxml import etree html = etree.parse('hello.html')print type(html) # 显示etree.parse() 返回类型 result = html.xpath('//li') print(result) # 打印&lt;li&gt;标签的元素集合 获取所有li元素下的所有class属性的值： 123456from lxml import etree html = etree.parse('hello.html')result = html.xpath('//li/@class') print(result) 获取li标签下href为www.baidu.com的a标签： 123456from lxml import etree html = etree.parse('hello.html')result = html.xpath('//li/a[@href="www.baidu.com"]') print(result) 获取li标签下所有span标签： 1234567891011from lxml import etree html = etree.parse('hello.html') #result = html.xpath('//li/span')#注意这么写是不对的：#因为 / 是用来获取子元素的，而 &lt;span&gt; 并不是 &lt;li&gt; 的子元素，所以，要用双斜杠 result = html.xpath('//li//span') print(result) 获取li标签下的a标签里的所有class： 123456from lxml import etree html = etree.parse('hello.html')result = html.xpath('//li/a//@class') print(result) 获取最后一个li的a的href属性对应的值： 12345678from lxml import etree html = etree.parse('hello.html') result = html.xpath('//li[last()]/a/@href')# 谓语 [last()] 可以找到最后一个元素 print(result) 获取倒数第二个li元素的内容： 1234567from lxml import etree html = etree.parse('hello.html')result = html.xpath('//li[last()-1]/a') # text 方法可以获取元素内容print(result[0].text) 获取倒数第二个li元素的内容的第二种方式： 123456from lxml import etree html = etree.parse('hello.html')result = html.xpath('//li[last()-1]/a/text()') print(result) 爬取豆瓣电影正在热映的电影12345678910111213141516171819202122232425262728293031323334353637383940import requestsfrom lxml import etree# 1.将目标网站的页面抓取下来# 请求头headers = &#123; "User-Agent":"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36", "Referer":"https://movie.douban.com/"&#125;url = "https://movie.douban.com/cinema/nowplaying/guangzhou/"response = requests.get(url,headers=headers)text = response.text# print(response.text)# 2.将抓取下来的页面按照一定规则提取html = etree.HTML(text)ul = html.xpath("//ul[@class='lists']")[0]# print(etree.tostring(ul,encoding="utf-8").decode("utf-8"))lis = ul.xpath("./li")movies = []for li in lis: title = li.xpath("@data-title")[0] score = li.xpath("@data-score")[0] duration = li.xpath("@data-duration")[0] region = li.xpath("@data-region")[0] director = li.xpath("@data-director")[0] actors = li.xpath("@data-actors")[0] thumbnail = li.xpath(".//img/@src")[0] movie = &#123; "title":title, "score":score, "duration":duration, "region":region, "director":director, "actors":actors, "thumbnail":thumbnail &#125; movies.append(movie)print(movies)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-网络爬虫-1]]></title>
    <url>%2F2018%2F09%2F28%2Fpython-21%E5%A4%A9%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-1%2F</url>
    <content type="text"><![CDATA[爬虫基础实际例子： 搜索引擎（百度谷歌） 伯乐在线 慧慧购物助手 数据分析与研究（数据冰山知乎专栏） 抢票软件 通俗理解：爬虫是一个模拟人类请求网站行为的程序，可以自动请求网页，并将数据爬取下来，然后使用一定规则提取有价值的数据 通用爬虫：是搜索引擎的爬取系统的重要组成部分，主要是将互联网的网页下载到本地，形成一个互联网内容的镜像备份。 聚焦爬虫：是面向特定需求的一种网络爬虫程序，与通用爬虫区别是聚焦爬虫是实施网页爬取的时候对内容进行筛选和处理，尽量保证值抓取与需求相关的网页信息。 https和http协议：http：hypertext transfer protocol：超文本传输协议，是一种发布和接收html页面的方法，服务器端口是80，http是无连接的、媒体独立的、无状态的 https：http协议的加密版本，在http下加入了SSL层，服务器端口是443 在浏览器中发送一个http请求： 当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。 当我们在浏览器输入URL http://www.baidu.com 的时候，浏览器发送一个Request请求去获取 http://www.baidu.com 的html文件，服务器把Response文件对象发送回给浏览器。 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。 当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。 URL URL是Uniform Resource Locator的简写，统一资源定位符。 一个URL由以下几部分组成： 1scheme://host:port/path/?query-string=xxx#anchor scheme：代表的是访问的协议，一般为http或者https以及ftp等。 host：主机名，域名，比如www.baidu.com。 port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。 path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。 query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。 anchor：锚点，后台一般不用管，前端用来做页面定位的。 在浏览器中请求一个url，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值进行编码。 http协议中一共定义了八种请求方法 get：只从服务器上获取数据，并不会对服务器上的资源产生任何影响 post：向服务发送数据，上传文件等，会对服务器资源产生影响时候会使用 post 请求 以上是在网站开发中常用的两种方法。并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌，有可能一个应该使用get方法的请求就一定要改成post请求，这个要视情况而定。 请求头常见参数： 在http协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据放在body中（在post请求中），第三个就是把数据放在head中。这里介绍在网络爬虫中经常会用到的一些请求头参数： User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。如果我们是通过爬虫发送请求，那么我们的User-Agent就是Python，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。 Referer：表明当前这个请求是从哪个url过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。 Cookie：http协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用cookie来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送cookie信息了。 常见响应状态码 200：请求正常，服务器正常的返回数据。 301：永久重定向。比如在访问www.jingdong.com的时候会重定向到www.jd.com。 302：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。 400：请求的url在服务器上找不到。换句话说就是请求url错误。 403：服务器拒绝访问，权限不够。 500：服务器内部错误。可能是服务器出现bug了。 urllib库urllib库是Python中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。 urlopen函数：在Python3的urllib库中，所有和网络请求相关的方法，都被集到urllib.request模块下面了，以先来看下urlopen函数基本的使用： 123from urllib import requestresp = request.urlopen('http://www.baidu.com')print(resp.read()) url：请求的url。 data：请求的data，如果设置了这个值，那么将变成post请求。 返回值：返回值是一个http.client.HTTPResponse对象，这个对象是一个类文件句柄对象。有read(size)、readline、readlines以及getcode等方法。 urlretrieve函数：这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地： 12from urllib import requestrequest.urlretrieve('http://www.baidu.com/','baidu.html') urlencode函数：用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用urlencode函数来实现。urlencode可以把字典数据转换为URL编码的数据。示例代码如下： 1234from urllib import parsedata = &#123;'name':'爬虫基础','greet':'hello world','age':100&#125;qs = parse.urlencode(data)print(qs) parse_qs函数：可以将经过编码后的url参数进行解码。示例代码如下： 123from urllib import parseqs = "name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&amp;greet=hello+world&amp;age=100"print(parse.parse_qs(qs)) urlparse和urlsplit：有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用urlparse或者是urlsplit来进行分割。示例代码如下： 1234567891011from urllib import request,parseurl = 'http://www.baidu.com/s?username=zhiliao'result = parse.urlsplit(url)# result = parse.urlparse(url)print('scheme:',result.scheme)print('netloc:',result.netloc)print('path:',result.path)print('query:',result.query) urlparse和urlsplit基本上是一模一样的。唯一不一样的地方是，urlparse里面多了一个params属性，而urlsplit没有这个params属性。比如有一个url为：url = &#39;http://www.baidu.com/s;hello?wd=python&amp;username=abc#1&#39;，那么urlparse可以获取到hello，而urlsplit不可以获取到。url中的params也用得比较少。 request.Request类：如果想要在请求的时候增加一些请求头，那么就必须使用request.Request类来实现。比如要增加一个User-Agent，示例代码如下： 1234567from urllib import requestheaders = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'&#125;req = request.Request("http://www.baidu.com/",headers=headers)resp = request.urlopen(req)print(resp.read().decode("utf-8")) 抓取糗事百科首页数据：12345678910from urllib import request,parseurl = "https://www.qiushibaike.com/"# 加上请求头headers=&#123; "User-Agent":"User-Agent:Mozilla/5.0", "Referer":"https://www.baidu.com/link?url=H0u-m1kzYmulOwEVq8vMNu-CWw01u04Ote18sY1pL5Um94W1zqnPxoj2tvi96mJf&amp;wd=&amp;eqid=ebcea8f70005e2a0000000065bacfd1c"&#125;req = request.Request(url,headers=headers)resp = request.urlopen(req)print(resp.read().decode("utf-8")) ProxyHandler处理器（代理）很多网站都会检测某一段时间某个ip的访问次数（通过流量统计，系统日志等等），如果访问次数过多会被禁止ip访问。 1234567891011121314from urllib import request# 没有使用代理# url = "http://www.baidu.com"# resp = request.urlopen(url)# print(resp.read().decode("utf-8"))# 使用代理url = "http://www.baidu.com"handler = request.ProxyHandler(&#123;"http":"192.168.1.1:8080"&#125;)opener = request.build_opener(handler)req = request.Request(url)resp = opener.open(req)print(resp.read().decode("utf-8")) requests库虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。 安装利用pip可以非常方便的安装： 1pip install requests 中文文档：http://docs.python-requests.org/zh_CN/latest/index.htmlgithub地址：https://github.com/requests/requests 发送GET请求最简单的发送get请求就是通过requests.get来调用： 1response = requests.get("http://www.baidu.com/") 添加headers和查询参数：如果想添加 headers，可以传入headers参数来增加请求头中的headers信息。如果要将参数放在url中传递，可以利用 params 参数。相关示例代码如下： 1234567891011121314151617181920212223import requestskw = &#123;'wd':'中国'&#125;headers = &#123;"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36"&#125;# params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()response = requests.get("http://www.baidu.com/s", params = kw, headers = headers)# 查看响应内容，response.text 返回的是Unicode格式的数据print(response.text)# 查看响应内容，response.content返回的字节流数据print(response.content)# 查看完整url地址print(response.url)# 查看响应头部字符编码print(response.encoding)# 查看响应码print(response.status_code) 发送POST请求最基本的POST请求可以使用post方法： 1response = requests.post("http://www.baidu.com/",data=data) 传入data数据： 这时候就不要再使用urlencode进行编码了，直接传入一个字典进去就可以了。比如请求拉勾网的数据的代码： 123456789101112131415161718import requestsurl = "https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&amp;needAddtionalResult=false&amp;isSchoolJob=0"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36', 'Referer': 'https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput='&#125;data = &#123; 'first': 'true', 'pn': 1, 'kd': 'python'&#125;resp = requests.post(url,headers=headers,data=data)# 如果是json数据，直接可以调用json方法print(resp.json()) 使用代理使用requests添加代理也非常简单，只要在请求的方法中（比如get或者post）传递proxies参数就可以了。示例代码如下： 123456789101112131415import requestsurl = "http://httpbin.org/get"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',&#125;proxy = &#123; 'http': '171.14.209.180:27829'&#125;resp = requests.get(url,headers=headers,proxies=proxy)with open('xx.html','w',encoding='utf-8') as fp: fp.write(resp.text) cookie如果在一个响应中包含了cookie，那么可以利用cookies属性拿到这个返回的cookie值： 1234567import requestsurl = "http://www.renren.com/PLogin.do"data = &#123;"email":"970138074@qq.com",'password':"pythonspider"&#125;resp = requests.get('http://www.baidu.com/')print(resp.cookies)print(resp.cookies.get_dict()) session之前使用urllib库，是可以使用opener发送多个请求，多个请求之间是可以共享cookie的。那么如果使用requests，也要达到共享cookie的目的，那么可以使用requests库给我们提供的session对象。注意，这里的session不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用requests来实现。示例代码如下： 12345678910111213141516import requestsurl = "http://www.renren.com/PLogin.do"data = &#123;"email":"970138074@qq.com",'password':"pythonspider"&#125;headers = &#123; 'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"&#125;# 登录session = requests.session()session.post(url,data=data,headers=headers)# 访问大鹏个人中心resp = session.get('http://www.renren.com/880151247/profile')print(resp.text)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java中的i++和++i效率分析]]></title>
    <url>%2F2018%2F09%2F27%2Fjava-2%2F</url>
    <content type="text"><![CDATA[前言自增运算符的的i++和++i都可以实现增1，在表面看也是先赋值再运算和先运算再赋值的区别 1234567891011121314151617public static void main(String[] args) &#123; int a = 7; /** * 先赋值，再自增 * n1 = a; * a = a+1; */ int n1 = a++; /** * 先自增，再赋值 * a = a+1; * n2 = a; */ int n2 = ++a; System.out.println("n1 = "+n1); System.out.println("n2 = "+n2);&#125; 12n1 = 7n2 = 9 分析在csdn上看到： 12i++：Fetch i,copy i,increment i,return copy; //取出i，复制i，增加i，返回副本； ++i：Fetch i,increment i,return i; //取出i，增加i，返回i； i++会比++i多需要一个copy值在内存中，原则上来说++i会更高效]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-链表]]></title>
    <url>%2F2018%2F09%2F26%2Fjava-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言动态数组，栈，队列都是底层依托于静态数组的，而链表是一种真正的动态数据结构,真正的动态，不需要处理固定的容量，缺点是失去了随机访问的能力 节点在list中定义了Node节点内部类，外部不需要关心节点的结构，内部类合适 1234567891011121314private class Node&#123; public E e; public Node next; public Node(E e,Node next)&#123; this.e = e; this.next = next; &#125; public Node(E e)&#123; this(e,null); &#125; public Node()&#123; &#125;&#125; 添加操作12345678//链表中定义了两个内部属性，虚拟头结点和长度private Node dumyHead;private int size;//链表的构造器public MyList()&#123; size = 0; dumyHead = new Node(null,null);&#125; 123456789101112131415161718192021222324//在指定位置添加节点public Boolean add(int index,E e)&#123; if(index &lt; 0 || index &gt; size)&#123; return false; &#125; //头结点为虚拟头结点，此结点的数据为null，next指针指向第一个元素 Node prev = dumyHead; for(int i=0;i&lt;index-1;i++)&#123; prev = prev.next; &#125; Node node = new Node(e); node.next=prev.next; prev.next = node; size++; return true;&#125;//在链表头添加数据public void addFirst(E e)&#123; add(0, e);&#125;//在链表尾部添加节点public void addLast(E e)&#123; add(size, e);&#125; 获取链表元素12345678910111213141516171819//获取链表中index位置的节点的元素public E getIndex(int index)&#123; if(index &lt;0||index&gt;=size)&#123; throw new IllegalArgumentException("fial,sorry"); &#125; Node cur = dumyHead.next; for(int i=0;i&lt;index;i++)&#123; cur = cur.next; &#125; return cur.e;&#125;//获取第一个元素public E getFirst()&#123; return getIndex(0);&#125;//获取最后一个元素public E getlast()&#123; return getIndex(size-1);&#125; 修改链表元素1234567891011//设置链表中第index个位置的元素为epublic void set(int index,E e)&#123; if(index&lt;0||index&gt;=size)&#123; throw new IllegalArgumentException("fail"); &#125; Node cur = dumyHead.next; for(int i=0;i&lt;index;i++)&#123; cur =cur.next; &#125; cur.e = e;&#125; 删除元素123456789101112131415//在链表中删除index位置的元素，并返回被删除的元素public E remove(int index)&#123; if(index&lt;0||index&gt;=size)&#123; throw new IllegalArgumentException("fail"); &#125; Node prev = dumyHead; for(int i=0;i&lt;index;i++)&#123; prev = prev.next; &#125; Node retNode = prev.next; prev.next = retNode.next; retNode.next = null; size--; return retNode.e;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的浅复制和深复制]]></title>
    <url>%2F2018%2F09%2F25%2Fpython%E7%9A%84%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言发现自己基础还是有待加强 copycpoy.copy() 浅复制，只复制父对象的内容，不会复制父对象里面的子对象的内容，只复制了子对象的引用 copy.deepcopy() 深复制，会复制整个父对象，包括父对象里面的子对象的所有内容（比浅复制更加耗费内存空间） 1234567891011import copya = [1,2,3,['a','b','c']]b = ac = copy.copy(a)d = copy.deepcopy(a)a.append(4)a[3].append('d')print(a)print(b)print(c)print(d) 打印结果为 1234[1, 2, 3, ['a', 'b', 'c', 'd'], 4][1, 2, 3, ['a', 'b', 'c', 'd'], 4][1, 2, 3, ['a', 'b', 'c', 'd']][1, 2, 3, ['a', 'b', 'c']]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的map函数]]></title>
    <url>%2F2018%2F09%2F25%2Fpython%E7%9A%84map%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言在牛客网上做练习python的时候，碰见一道题，不太了解map函数，所以便查了一些资料,记录一下 原题：下列代码运行结果是？ a = map(lambda x: x**3, [1, 2, 3]) list(a) A：[1,6,9] B：[1,12,27] C：[1,8,27] 总结： map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 列表list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 所以选：C]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络编程]]></title>
    <url>%2F2018%2F09%2F25%2Fpython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言主要是学习温习python网络编程相关 网络是什么使用网络能让多方通信，可以进行数据传输 网络编程就是：让在不同电脑上的软件能够进行数据传输，即：进程间的通信 IP地址和端口12ipconfig：windows查看ipifconfig：linux查看ip 每个IP地址都分为两部分：网络地址和主机地址 私有ip有三类： 10.0.0.0~10.255.255.255 172.16.255.255~172.31.255.255 192.168.0.0~192.168.255.255 端口 一个端口号就代表一个进程 端口通过端口号来标记：0-65535 有分知名端口号和动态端口号：（一般情况下一个程序需要知名端口号需要root权限） 知名端口号：0-1023 动态端口号：1024-65535 socket不同电脑的进程之间进程通信，首先需要唯一的标识一个进程，才可以进行通信，在一台电脑上可以有进程号（PID）来标识一个进程，在不同电脑之间可以通过【ip+协议+端口】来唯一标识一个进程 socket（俗称：套接字）是实现进程间通信的一种方式，它可以实现不同主机之间的进程的通信 创建socket 12import socketsocket.socket(AddressFamily,Type) AddressFamily AF_INET：用于网络进程间通信（一般使用这个） AF_UNIX：同一台主机间进程的通信 Type：套接字类型 SOCK_STREAM：流式套接字，主要用于TCP SOCK_DGRAM：数据套接字，主要用于UDP UDP1234567891011121314# 创建一个udp套接字import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)# 发送数据,b"hello"是bytes类型# s.sendto(b"hello",("192.168.120.124",5656))send_data = "hello"s.sendto(send_data.encode("utf-8"),("192.168.120.124",5656))s.close()# 接受udp数据local_addr = ("",5656) #绑定本地ip端口为5656s.bind(local_addr)data = s.recvfrom(1024) #data是一个元组，第一个元素是接收的内容，第二个元素也是一个元组，包含着发送方的ip+端口print(data) TCPtcp协议：传输控制层，是一种面向连接的，可靠的，基于字节流的传输通信协议，由IETF的RFC 793定义 tcp通信需要经过创建连接，数据传送，终止连接三个步骤 12345678# 创建一个tcp客户端import sockets = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect(("10.1.1.142",7890))s.send("hello".encode("utf-8"))recv_data = s.recv(1024)prin(recv_data)s.close() 12345678910# 创建tcp服务端import socketserver = socket.socket(socket.AF_INET,socket.SOCK_STREAM)server.bind(("10.1.1.142",7890))server.listen(128)client,ip_tutple = server.accept() #返回一个元组，第一个元素是一个套接字，第二个元素是元组，包含客户端的ip+端口data = client.recv(1024)print(data)client.close()server.close() tcp注意点 tcp服务器一般情况都需要绑定，否则 客户端找不到服务器 tcp客户端一般不绑定，因为主动连接的服务器，所以只要确定服务器的ip、port就好 tcp服务器通过listen可以将socket创建出来的主动套接字变为被动，这是做tcp服务器必须要做的 当客户需要连接服务器时，就需要使用connect进行连接，udp不需要连接可以直接发送 当一个tcp客户端连接服务器时，服务器端会有一个新的套接字，这个套接字标记这个客户端，单独为这个客户端服务 listen后的套接字是被动套接字，用来接收新的客户端请求，而accept返回的新套接字是标记这新客户端的 关闭listen后的套接字就意味着套接字关闭了，导致新的客户端不能连接，但是之前已经连接的客户端可以正常访问]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现飞机大战]]></title>
    <url>%2F2018%2F09%2F24%2Fpython%2F</url>
    <content type="text"><![CDATA[前言这个算是自己的第一个实现的小项目吧，也有点小开心（大神请无视、、）学习了python有一点时间了，跟着视频教学，慢慢的一点点的敲出来。也算是自己慢慢写的第一篇项目博客哈^_^ 写的有点差，想看源码的可以去我的github仓库：https://github.com/liizzZ/airplane 主要使用pygame模块实现，这个模块基本实现了这里需要的类和方法，python真的集成很高，这个模块可以让我们快速地就搭建出一个小小的东西来 主要实现123if __name__ == '__main__': game = PlaneGame() game.start_game() PlaneGame() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#主程序class PlaneGame(): #游戏初始化 def __init__(self): print("游戏初始化") self.screen = pygame.display.set_mode((SCREEN_RECR.width,SCREEN_RECR.height)) self.clock = pygame.time.Clock() self.__create_sprites() pygame.time.set_timer(CREATE_ENEMY_EVENT,1000) pygame.time.set_timer(OPEN_FIRE,400) #创建精灵 def __create_sprites(self): bg1 = Background("./images/background.png") bg2 = Background("./images/background.png") bg2.rect.y = -bg2.rect.height self.back_group = pygame.sprite.Group(bg1,bg2) self.enemy_group = pygame.sprite.Group() self.hero = Hero() self.hero_group = pygame.sprite.Group(self.hero) #监听事件处理 def __event_handler(self): for event in pygame.event.get(): if event.type == pygame.QUIT: self.__game_over() elif event.type == CREATE_ENEMY_EVENT: print("出现敌机") enemy = Enemy() self.enemy_group.add(enemy) elif event.type == OPEN_FIRE: self.hero.fire() # 第一种实现键盘监听，但是这种方式的话，只能处理一次按下移动一格，不能实现连续移动操作 # elif event.type == pygame.KEYDOWN and pygame.K_RIGHT: # print("按下右键") #第二种实现键盘事件监听 keys_presswd = pygame.key.get_pressed() if keys_presswd[pygame.K_RIGHT]: self.hero.rect.x += 3 elif keys_presswd[pygame.K_LEFT]: self.hero.speed = -3 else: self.hero.speed = 0 # 碰撞检测 def __check_collide(self): pygame.sprite.groupcollide(self.hero.bullets,self.enemy_group,True,True) enemies = pygame.sprite.groupcollide(self.hero_group,self.enemy_group,True,True) if len(enemies) &gt; 0: self.hero.kill() self.__game_over() pass # 更新精灵组 def __update_sprites(self): # 背景图片 self.back_group.update() self.back_group.draw(self.screen) # 敌机 self.enemy_group.update() self.enemy_group.draw(self.screen) # 我方飞机 self.hero_group.update() self.hero_group.draw(self.screen) # 子弹 self.hero.bullets.update() self.hero.bullets.draw(self.screen) @staticmethod def __game_over(): print("游戏结束") pygame.quit() exit() # 开始游戏 def start_game(self): print("游戏开始") while True: pass #1设置刷新帧率 self.clock.tick(60) #2事件监听 self.__event_handler() #3碰撞检测 self.__check_collide() #4更新精灵组 self.__update_sprites() #5更新显示 pygame.display.update() 设置常量 12345678#屏幕区域SCREEN_RECR = pygame.Rect(0,0,480,700)#刷新帧率FRAME_PRE_SEC = 60#创建敌机的定时器事件常量CREATE_ENEMY_EVENT = pygame.USEREVENT#发射子弹的事件OPEN_FIRE = pygame.USEREVENT + 1 精灵基类 1234567891011class GameSprite(pygame.sprite.Sprite): # 初始化方法，默认传参速度为1，需要传的图片路径参数 def __init__(self,image_name,speed=1): super().__init__() self.image = pygame.image.load(image_name) self.rect = self.image.get_rect() self.speed = speed # 主要处理精灵对象的属性的更新操作 def update(self): #垂直方向上的移动速度 self.rect.y += self.speed 背景图片类，继承精灵基类 1234567class Background(GameSprite): def update(self): super().update() # 背景图向下移动，实现飞机向上飞行的错觉 if self.rect.y &gt;= SCREEN_RECR.height: self.rect.y = -SCREEN_RECR.height 敌机类 123456789101112131415class Enemy(GameSprite): def __init__(self): super().__init__("./images/enemy1.png") self.speed = random.randint(1,3) self.rect.bottom = 0 self.rect.x = random.randint(0,480-57) def update(self): super().update() if self.rect.y &gt;= SCREEN_RECR.height: pass if self.rect.y &gt; SCREEN_RECR.height: self.kill() def __del__(self): print("敌机被销毁：%s" %self.rect) 我方飞机类 1234567891011121314151617181920212223class Hero(GameSprite): def __init__(self): super().__init__("./images/me1.png",0) self.rect.centerx = SCREEN_RECR.centerx self.rect.bottom = SCREEN_RECR.bottom - 70 self.bullets = pygame.sprite.Group() def update(self): self.rect.x += self.speed if self.rect.left &lt; 0: self.rect.left = 0 elif self.rect.right &gt; SCREEN_RECR.right: self.rect.right = SCREEN_RECR.right def fire(self): print("发射子弹") for i in (0,1,2): bullet = Bullet() bullet.rect.bottom = self.rect.y - i* 20 bullet.rect.centerx = self.rect.centerx self.bullets.add(bullet) 子弹类 123456789101112class Bullet(GameSprite): def __init__(self): super().__init__("./images/bullet1.png",-2) def update(self): if self.rect.bottom &lt;= 0: self.kill() self.rect.y += self.speed def __del__(self): print("子弹被销毁：%s" % self.rect)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题（收集一）]]></title>
    <url>%2F2018%2F09%2F23%2Fjava-1%2F</url>
    <content type="text"><![CDATA[java基础知识JDK和JRE的区别Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）–编译器、调试器和其他工具。 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 ‘static’关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。 是否可以在static环境中访问非static变量？static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上 Java支持的数据类型有哪些？什么是自动拆装箱？Java语言支持的8种基本数据类型是： byte short int long float double boolean char 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程 Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。 Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。 Java支持多继承么？Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能） 接口和抽象类的区别是什么？Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 抽象类可以在不提供接口方法实现的情况下实现接口。 Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或 a 者是public。 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。 也可以参考JDK8中抽象类和接口的区别 什么是值传递和引用传递？值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递 ###进程和线程的区别是什么？ 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。 线程与进程的区别归纳： 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 调度和切换：线程上下文切换比进程上下文切换要快得多。 在多线程OS中，进程不是一个可执行的实体。 创建线程有几种不同的方式？你喜欢哪一种？为什么？有4种方式可以用来创建线程： 继承Thread类 实现Runnable接口 应用程序可以使用Executor框架来创建线程池 实现Callable接口实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 概括的解释下线程的几种可用状态 新建( new )：新创建了一个线程对象。 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 阻塞可以分为三种情况 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态###同步方法和同步代码块的区别是什么？ 同步方法默认用this或者当前类class对象作为锁； 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法； 同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰； 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 什么是死锁(deadlock)？所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件： 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。 如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 Java集合类框架的基本接口有哪些？集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。 Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有： Collection：代表一组对象，每一个对象都是它的子元素。 Set：不包含重复元素的Collection。 List：有顺序的collection，并且可以包含重复元素。 Map：可以把键(key)映射到值(value)的对象，键不能重复。 为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 什么是迭代器(Iterator)？Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。 Iterator和ListIterator的区别是什么？下面列出了他们的区别： Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？一：快速失败（fail—fast） ​ 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。 ​ 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 ​ 注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。 ​ 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 ​ 二：安全失败（fail—safe） ​ 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而先复制原有集合内容，在拷贝的集合上进行遍历。 ​ 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 ​ 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 ​ 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 java中HashMap的工作原理是什么？Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 hashCode()和equals()方法的重要性体现在什么地方？ Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 HashMap和Hashtable有什么区别？HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： HashMap允许键和值是null，而Hashtable不允许键或者值是null。 Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。 一般认为Hashtable是一个遗留的类。 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？下面列出了Array和ArrayList的不同点： Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 Array大小是固定的，ArrayList的大小是动态变化的。 ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 ArrayList和LinkedList有什么区别？ArrayList和LinkedList都实现了List接口，他们有以下的不同点： ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 也可以参考ArrayList vs. LinkedList。 ###Comparable和Comparator接口是干什么的？列出它们的区别 Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 什么是Java优先级队列(Priority Queue)？PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是一个渐进上界 。 大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。 如何权衡是使用无序的数组还是有序的数组？有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。 Java集合类框架的最佳实践有哪些？根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的数量是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。 为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 编程的时候接口优于实现。 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 Enumeration接口和Iterator接口的区别有哪些？Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。 HashSet和TreeSet有什么区别？HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。 另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？垃圾回收器(garbage collector)决定回收某对象时，就会运行该对象的finalize()方法 但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 ###Java中的两种异常类型是什么？他们有什么区别？Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。这里有Java异常处理的一些小建议。Java中Exception和Error有什么区别？ ###throw和throws有什么区别？throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 异常处理完成以后，Exception对象会发生什么变化？Exception对象会在下一个垃圾回收过程中被回收掉 finally代码块和finalize()方法有什么区别？无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。 什么是Applet？java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。 解释一下Applet的生命周期applet可以经历下面的状态： Init：每次被载入的时候都会被初始化。 Start：开始执行applet。 Stop：结束执行applet。 Destroy：卸载applet之前，做最后的清理工作。 当applet被载入的时候会发生什么？首先，创建applet控制类的实例，然后初始化applet，最后开始运行。 Applet和普通的Java应用程序有什么区别？applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。 进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。 最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。 Java applet有哪些限制条件？主要是由于安全的原因，给applet施加了以下的限制： applet不能够载入类库或者定义本地方法。 applet不能在宿主机上读写文件。 applet不能读取特定的系统属性。 applet不能发起网络连接，除非是跟宿主机。 applet不能够开启宿主机上其他任何的程序。 什么是不受信任的applet？不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。 从网络上加载的applet和从本地文件系统加载的applet有什么区别？当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制。 当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的。 从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。 applet类加载器是什么？它会做哪些工作？当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。 当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的 applet安全管理器是什么？它会做哪些工作？applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。 弹出式选择菜单(Choice)和列表(List)有什么区别Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。 什么是布局管理器？布局管理器用来在容器中组织组件 滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？Scrollbar是一个组件，不是容器。而ScrollPane是容器。ScrollPane自己处理滚动事件。 哪些Swing的方法是线程安全的？只有3个线程安全的方法： repaint(), revalidate(), and invalidate() java虚拟机什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 Java中垃圾回收有什么目的？什么时候进行垃圾回收？垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。 垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。 System.gc()和Runtime.gc()会做什么事情？这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。 Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。 永久代是用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含： 类的方法(字节码…) 类名(Sring对象) .class文件读到的常量信息 class对象相关的对象列表和类型列表 (e.g., 方法对象的array). JVM创建的内部对象 JIT编译器优化用的信息 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 在Java中，对象什么时候可以被垃圾回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了 。 JVM的永久代中会发生垃圾回收么？垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区) Javaweb]]></content>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell基础知识汇总]]></title>
    <url>%2F2018%2F09%2F23%2Fshell-1%2F</url>
    <content type="text"><![CDATA[概述shell就是一个命令行解析器，接收应用程序的命令或者用户的命令，然后去调用操作系统内核，具备简洁、高效的特性 一般shell脚本顶部为：#!/bin/bash 执行脚本可以使用一下两种方式，第一种方式本质上是bash来执行脚本，不需要文件的执行权限。第二种是脚本自身自己执行，需要脚本文件的执行权限 12sh test.sh./test.sh 变量一般由字母，数字，下划线组成，数字不能开头 linux中，变量分为：系统变量，自定义变量 系统变量\$HOME、\$PWD、\$SHELL、\$USER 等等 1234echo $HOME:/rootecho $PWD:/home/liizzzecho $SHELL:/bin/bashecho $USER:liizzz 自定义变量在给自定义变量赋值的时候，‘’=‘’ 两侧不能有空格！！ 既然有变量，那么就会考虑到变量的类型和作用域，在bash中，变量的默认类型都是字符串类型，不能直接进行数值计算的。可以使用 export 变量名 的方式来提升变量的作用域为全局环境变量 1234A=100echo 'A' = $AUNSET Aecho $A : 空 静态变量：readonly（静态变量不能unset） 特殊变量$#：代表输入参数的个数 $[0-9]：依次代表输入的参数，$0代表命令行本身 $@和$* ：都可以代表输入的所有参数，区别是$@参数分开对待。$*会把所有参数当成一个整体集合 $?：表示最后一次命令返回的状态，如果这个变量值为0，证明上一次命令正确执行，如果非0，表示上一次命令执行不正确 1echo "$0,$1,$2" 运算符 $(())：运算符间不需要空格 $[]：运算符间不需要空格 expr +,-,\*,/,%：expr运算符间必须有空格（等号两边不能有空格） 条件判断语法[condition] ，condition前后要有空格，条件非空即为true 整数之间比较 =：字符串比较 -lt：小于 -le：小于等于 -eq：等于 -gt：大于 -ge：大于等于 -ne：不等于 123456[root@localhost shell_test]# [ 8 -le 9 ][root@localhost shell_test]# echo $?0[root@localhost shell_test]# [ 8 -ge 9 ][root@localhost shell_test]# echo $?1 判断文件权限判断一个文件是否有此权限 -r ：有读权限 -w：有写权限 -x：有执行权限 123[root@localhost shell_test]# [ -r a.sh ][root@localhost shell_test]# echo $?0 判断文件类型 -f：文件存在并且是一个常规文件 -e：文件存在 -d：文件存在但是是一个目录 123456[root@localhost shell_test]# [ -d test ][root@localhost shell_test]# echo $?0[root@localhost shell_test]# [ -f test ][root@localhost shell_test]# echo $?1 流程控制if12345678910if [ condition ];then ...fi或者if [ condition ]then ...fi case值）：表示变量的取值 ;;：功能如同java的break *)：功能同default 1234567891011case $1 in1) echo "1";;2) echo "2";;*) echo "3++";;esac for相当于java中的两个循环，一个普通循环，一个foreach循环 12345678910111213s=0for((i=1;i&lt;=100;i++))do s=$[$i+$s]doneecho $s或者for i in $*do echo "right-$i"done while1234while [condition]do ...done READ读取控制台输入read (选项)(参数) 选项： 指定读取值时的提示符 指定读取值时等待的时间（秒） 参数：指定读取值时的变量名 12read -t 5 -p "请输入0-9: " Nameecho $[$Name*7] 函数常用的系统函数 basename：删除所有的前缀包括/ ，然后显示字符串 dirname：删除文件名，留下路径目录 123456[root@localhost shell_test]# basename /home/tar/test.jpgtest.jpg[root@localhost shell_test]# basename /home/tar/test.jpg pgtest.j[root@localhost shell_test]# dirname /home/tar/test.jpg /home/tar 自定义函数 必须在调用函数之前，声明函数，shell脚本是逐行运行的，不会先编译 函数返回值，只能通过$?来获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值，return后跟数值 1234567891011function sum()&#123; s=0 s=$[$1+$2] echo $s&#125;read -p "input number: " P1read -p "input number: " P2sum $P1 $P2 SHELL工具cutcut (选项) filename 选项： -f：列号，提取第几列 -d：分隔符，按照指定分隔符分隔列 123456789101112[root@localhost shell_test]# cut -d " " -f 2,3 a.txtzhenzhou shan haiguan[root@localhost shell_test]# cut -d " " -f 2 a.txtzhenzhouguan sedsed是一种流编辑器，它一次处理一行内容，处理时，把当前处理的行存储到临时缓冲区，成为“模式空间”，接着用sed命令处理缓冲内容。处理完成后，把缓冲区的内容送往屏幕，接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非使用重定向存储输出。 sed [选项] ‘command’ filename 选项 -e：直接在指令模式上进行sed的动作编辑 command a：新增，a后面可以接字符串，在下一行出现 d：删除 s：查找并替换 123456789101112131415161718192021shen zhenguang zhoufo shanzhu haidong guan# 在第二行后面增加字符串[root@localhost shell_test]# sed "2a beijing" a.txtshen zhenguang zhoubeijingfo shanzhu haidong guan# 删除字符串[root@localhost shell_test]# sed "/zhu/d" a.txtshen zhenguang zhoufo shandong guan awk强大的文本分析工具，把文件逐行读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理 awk [选项] ‘pattern1{action1} pattern2{action2}..’ filename pattern：表示awk在数据中查找的内容，就是匹配模式 action：在找到匹配内容时所指向的一系列命令 选项 -F：指定输入文件的折分隔符 -v：赋值一个用户定义变量 sortsort命令是在linux中非常有用的，它将文件进行排序，并将排序结果进行标准化输出 sort (选项)(参数) 常用选项 -n：按照数值的大小进行排序 -r：以相反的顺序进行排序 -t：设置排序时所用的分隔字符 -k：指定需要排序的列]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本知识]]></title>
    <url>%2F2018%2F09%2F23%2Fgit-1%2F</url>
    <content type="text"><![CDATA[前言程序员怎么会不上github，上github怎能不会git 下载安装官网：https://git-scm.com Git的结构空间工作区-暂存区-本地库-远程仓库 git初始化1git init //初始化 .git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要胡乱修改 签名user.name： user.email： 作用：区分不同开发人员 命令 项目级别 12git config user.name xxxgit config user.email xxx@qq.com //信息存储在./.get/config文件中 系统用户级别： 12git config --global user.name xxxgit config --global user.email xxx@qq.com 级别优先级： 就近原则 如果系统签名，就以系统签名为准 二者都没有不允许添加提交以及查看操作状态 git add .：存储到 暂存区 git rm –cache：从暂存区撤回工作区 git commit -m “xxx” 文件 ：提交文件到本地仓库（在idea中，要使用单引号） git status：看工作区、暂存区状态 日志相关 git log：查看提交记录 git log –pretty online：以一行一条记录的方式显示历史记录 git log –oneline： git log reflog： 前进后退 git reset –hard 索引值：版本的前进后退 git reset –hard HEAD^：一个^表示后退一行 git reset –hard ~n：n表示后退几行 本地分支在版本控制中，可以有多个分支向多个方向前进，好处是可以让团队同时推进多个功能开发，提高开发效率，在各个分支的开发过程中，如果有一个分支死亡，则不会影响其他分支，死亡的分支删除即可 git branch [分支名]：创建分支 git branch -v：查看分支 git checkout [分支名]：切换分支 git checkout –b [分支名]：创建新分支并切换 合并分支： 切换到接受合并的分支上（git checkout master） 执行merge 命令（git merge toko） 连接远程仓库在本地创建远程仓库的别名 git remote add origin [url]: git remote-v：查看远程仓库别名 推送git push [别名] {分支名}： 克隆git clone [远程地址] 拉取pull = fetch + merge git fecth [][][] {} git merge [] {}]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-实用常用命令]]></title>
    <url>%2F2018%2F09%2F22%2Flinux-2%2F</url>
    <content type="text"><![CDATA[推荐一个查询linux命令网址https://wangchujiang.com/linux-command/ 帮助指令 man ：查看Linux中的指令帮助、配置文件帮助和编程帮助等信息 help ：用于显示shell内部命令的帮助信息。help命令只能显示shell内部的命令帮助信息。而对于外部命令的帮助信息只能使用man或者info命令查看。文件目录类 pwd ls -选项 -a：显示当前目录的所有文件和目录，包括隐藏文件 -l：以列表的形式显示 cd mkdir -p：创建多级目录 rmdir：删除空目录，如果此目录下有文件则无法删除，如果要删除非空目录：rm -rf touch：创建空文件，可以一次性创建多个文件 cp：拷贝指定文件到指定目录 -r：递归复制这个文件夹，复制的时候会把文件夹也一起复制过去 \cp：会强制覆盖原来的文件，不会提示 rm：移除删除指定的文件或者目录 -r：强制删除整个文件夹 -f：强制删除不提示 mv：移动文件、目录或重命名 cat：查看文件内容，已只读方式打开文件 -n：显示行号 cat -n /etc/inittab | more：分页查看内容，空格换页 more：以全屏幕的方式按页显示文本文件的内容，且内置多个快捷键 ‘&lt;’、’&gt;&gt;’：输出重定向、追加 12$ ls -l &gt; a.txt：把ls -l 显示的内容覆盖进a.txt文件，ls -al &gt;&gt; a.txt：把ls -l 显示的内容追加到a.txt中$ echo &quot;内容&quot; &gt;或&gt;&gt; 文件1：将字符串覆盖或追加进文件（cal：显示日历） echo、head、tail echo：输出内容到控制台 head：显示文件的开头部分，默认显示文件的前10行内容 -n 5：显示文件头5行，5可以是任意行数 tail：输出文件尾部的内容，默认显示文件尾部的后10行内容 -n 5：显示文件尾部5行 -f：实时追踪该文档的所有更新（工作会经常使用） ln：软链接，符号链接 ln -s /root lonktoroot：给root目录创建快捷方式 使用pwd查看软链接进入的目标目录，看到的仍是软链接的目录 rm -rf：删除软链接，删除软链接时候，后面不要带/，否则提示资源忙 history history 10：显示最近使用过的10个指令 ！10：执行历史指令编号为10的指令 时间日期类 date：显示当前时间 date +%Y-%m-%d：显示当前年、月、日 date +%H-%M-%S：显示时、分、秒 设置系统时间：date -s “2018-10-10 10:25:30” cal：显示日历 cal 2020：显示2020年的全部日历 搜索查找类 find -name：根据文件名查找 12find /root -name a.txtfind /root -name *.txt：通配符，查找txt结尾的文件 -user：查找属于指定用户名所有的文件 1find /root -user liizzz -size：按照指定文件大小查找文件 locate：locate：可以快速定位文件路径,由于locate基于数据查询，所以第一次运行，必须使用updatedb指令创建数据库 grep和 |: grep：过滤查找 |：管道符 -n：显示匹配行和行号 -i：忽略字母大小写 压缩和解压类 gzip 和 gunzip gzip：压缩文件 gunzip：解压文件 zip 和 unzip zip：压缩文件 -r：递归压缩 unzip：解压文件 -d：指定解压后文件存放的目录 tar：打包指令，生成的打包文后缀为：tar.gz文件 -c：产生.tar打包文件 -v：显示详细信息 -f：指定压缩后的文件名 -z：打包同时压缩 -x：解包.tar文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next-置顶首页文章的顺序（自定义）]]></title>
    <url>%2F2018%2F09%2F22%2Fhexo-1%2F</url>
    <content type="text"><![CDATA[安装库12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 设置top在需要指定首页置顶的文章中添加top属性12345title: hexo-next-自定首页文章的顺序（置顶）date: 2018-09-22 22:12:17tags: [hexo,next]category: [hexo-gihub]top: 10 top值越大，权重越大，例如有10篇文章需要置顶，则设置文章从1-10依次设置。记住top：后需要加空格]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础知识归纳]]></title>
    <url>%2F2018%2F09%2F22%2Flinux-1%2F</url>
    <content type="text"><![CDATA[目录结构基本介绍linux的文件系统是采用级层式的树状结构，在此结构中，最上层的目录是根目录“/”，然后在此目录下再创建其他目录在linux中，一切皆为文件 /bin：存放最经常使用的命令 /sbin：存放系 统管理员使用的系统管理程序 /root：该目录为系统管理员 /home：存放普通用户的主目录 /opt：给主机额外安装软件所在的安装目录 /usr/local：这个另一个给主机安装额外软件所在的目录 /boot：存放的是启动linux的一些核心文件，包括连接文件和镜像文件 /var：这个目录包含不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件 /etc：存放各种配置文件 /mnt：系统提供该目录是为了让用户挂载别的文件系统，我们可以将外部的文件存储挂载在/mnt上，然后进入该目录就可以查看内容 /tmp：存放一些临时文件 等等。。。。。总结 linux有且只有一个根目录 linux各个目录存放的内容都是规划好的，不用乱存放文件 linux以文件的形式管理我们的设备，因此，在linux下，一切皆为文件 linux的各个目录存放什么内容，必须有一个认识远程登陆 一般使用xshell登陆， 可以使用xftp进行文件迁移 用户管理linux是一个多用户多任务的操作系统，任何要使用系统资源的用户都必有一个用户账号linux用户至少需要属于一个用户组 基本命令 useradd 用户名 userdel 用户名：删除用户，但是不会删除家目录 userdel -r 用户名：同时删除用户和家目录 passwd 用户名：修改用户密码 id 用户：查询用户信息 用户组 groupadd 组名：增加一个组 groupdel 组名 useradd -g 组名 用户名： usermod 组名 用户名：修改账号的用户组 实用指令指定运行级别 0-关机 1-单用户（可以用于找回root密码） 2-多用户没有网络服务 3-多用户有网络服务 4-系统保留未使用 5-图形化界面 6-系统重启 系统运行的级别的配置文件：/etc/inittab int[0123456] 找回root密码开机–在引导的时候输入回车键–看到一个界面，选择第二行，输入一个小e–输入空格和1–按下回车–输入b–进入单用户模式–passwd修改root密码 组管理和权限管理]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F09%2F22%2Ftest%2F</url>
    <content type="text"><![CDATA[123public void study()&#123; System.out.println("yes,i am fine!");&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试文件]]></title>
    <url>%2F2018%2F09%2F22%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[火鸡如果你是一只火鸟我就是那一束火苗 我不想当烟花般灿烂的瞬间，只想当你普通的永远]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F09%2F22%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[6.4.1 版本中，如果设置为scheme: Gemini 或者 Pisces，在左侧的分类栏和个人信息栏会出现重合的情况，在点击home时，上下拖动文章不会触发，但是点击了其他选项，则会出现二者重合的情况，降低版本为6.4.0，则不会出现此情况]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
